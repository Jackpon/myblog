{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to here \uff01\n\u6211\u5efa\u6b64\u7f51\u7ad9\u7684\u521d\u8877\u662f\u4e3a\u4e86\u6574\u7406\u81ea\u5df1\u7b97\u6cd5\u601d\u8def\uff0c\u63a2\u7d22\u7b97\u6cd5\u7684\u4e50\u8da3\u3002",
            "title": "Home"
        },
        {
            "location": "/\u7ebf\u6027\u8868/Intersection of Two Linked Lists/",
            "text": "/*\n160. Intersection of Two Linked Lists\n\nWrite a program to find the node at which the intersection of two singly linked lists begins.\n\n\nFor example, the following two linked lists:\n\nA:          a1 \u2192 a2\n                   \u2198\n                     c1 \u2192 c2 \u2192 c3\n                   \u2197            \nB:     b1 \u2192 b2 \u2192 b3\nbegin to intersect at node c1.\n*/\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\n\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode>  set =new HashSet<>();\n        //\u5c06headA\u6dfb\u52a0\u5230set\n        while(headA != null){\n            set.add(headA);\n            headA = headA.next;\n        }\n        //\u6bd4\u8f83headB\uff0c\u4e0d\u540c\u5219return\n         while(headB != null) {\n             if(set.contains(headB))\n                 return headB;\n             headB = headB.next;\n         }\n        return null;\n    }\n}",
            "title": "Intersection of Two Linked Lists"
        },
        {
            "location": "/\u7ebf\u6027\u8868/Linked List Cycle/",
            "text": "/*\n141. Linked List Cycle\n\nGiven a linked list, determine if it has a cycle in it.\n*/\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\n\n\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n         Set<ListNode>  set =new HashSet<>();\n         while(head != null) {\n             if(set.contains(head))\n                 return true;\n             else \n                 set.add(head);\n             head = head.next; //\u9700\u8981\u6ce8\u610f\u662f\uff0c\u6b64\u64cd\u4f5c\u4f1a\u6539\u53d8head\u91cc\u7684\u5143\u7d20?\n         }\n         return false;\n    }\n}",
            "title": "Linked List Cycle"
        },
        {
            "location": "/\u7ebf\u6027\u8868/Merge Two Sorted Lists/",
            "text": "/*\n21. Merge Two Sorted Lists\n\nMerge two sorted linked lists and return it as a new list. \nThe new list should be made by splicing together the nodes of the first two lists.\n*/\n\n//\u5229\u7528\u9012\u5f52\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n\n\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode head;\n        if(l1 == null)\n            return l2;\n        if(l2 == null)\n            return l1;\n        if(l1.val < l2.val){\n            head = l1;\n            head.next = mergeTwoLists(l1.next,l2);\n        }else{\n            head = l2;\n            head.next = mergeTwoLists(l1,l2.next);\n        }\n        return head;\n    }\n}",
            "title": "Merge Two Sorted Lists"
        },
        {
            "location": "/\u7ebf\u6027\u8868/Palindrome Linked List/",
            "text": "/*\n234. Palindrome Linked List\n\nGiven a singly linked list, determine if it is a palindrome.\n\u5224\u65ad\u662f\u5426\u662f\u56de\u6587\uff1b\u5efa\u7acb\u6808\u6765\u5b9e\u73b0\n*/\n\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        ListNode he = head;\n        LinkedList<Integer> palindrome = new LinkedList<>();\n        while(head != null){\n            palindrome.push(head.val);\n            head = head.next;\n        }\n        while(he != null && ! palindrome.isEmpty()){\n            if(he.val != palindrome.pop())\n                return false;\n            he = he.next;\n        }\n        return true;\n    }\n}",
            "title": "Palindrome Linked List"
        },
        {
            "location": "/\u7ebf\u6027\u8868/Remove Duplicates from Sorted List/",
            "text": "/*\n83. Remove Duplicates from Sorted List\n\nGiven a sorted linked list, delete all duplicates such that each element appear only once.\n\nFor example,\nGiven 1->1->2, return 1->2.\nGiven 1->1->2->3->3, return 1->2->3.\n*/\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode list = head;\n        /*\n        \u6b64\u65f6list\u5bf9\u8c61\u76f8\u5f53\u4e8ehead\u5bf9\u8c61\u7684\u5f15\u7528\uff0c\u6240\u4ee5\u6539\u53d8list\u6307\u9488\u4f1a\u6539\u53d8head\uff0c\n        \u56e0\u4e3a\u5b83\u4eec\u6307\u9488\u662f\u540c\u4e00\u4e2a\uff0c\u800c\u6539\u53d8val\u5219\u4e0d\u4f1a\u6539\u53d8head\n        */\n        while(list != null && list.next != null){\n            if(list.next.val == list.val)\n                list.next =list.next.next;//\u76f8\u5e94\u7684\u4f1a\u6539\u53d8head\n            else\n                list = list.next;   //\u4e0d\u4f1a\u6539\u53d8head,\u4f46\u4f1a\u6539\u53d8list\uff0c\u7528\u4e00\u6b21\u51cf\u5c11\u4e00\u4e2a\u5143\u7d20\n        }\n        return head; //\u6240\u4ee5return list \u662f\u9519\u8bef\u7684\n    }\n}\n\n/*\nArrayList<Integer> arrayList =new ArrayList<>();\n    for (int i = 0; i < 5; i++) {\n        arrayList.add(i);\n    }\n\n    ArrayList<Integer> bArrayList =arrayList;\n    System.out.println(bArrayList);\n    bArrayList.add(5);\n    System.out.println(arrayList);\n    System.out.println(bArrayList);\n*/",
            "title": "Remove Duplicates from Sorted List"
        },
        {
            "location": "/\u7ebf\u6027\u8868/Remove Linked List Elements/",
            "text": "/*\n203. Remove Linked List Elements\n\nRemove all elements from a linked list of integers that have value val.\n\nExample\nGiven: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, val = 6\nReturn: 1 --> 2 --> 3 --> 4 --> 5\n*/\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        while (head != null && head.val == val) head = head.next;//\u53bb\u9664\u5934\u5143\u7d20\u4e3aval\u7684\n        ListNode curr = head;\n        while (curr != null && curr.next != null)\n            if (curr.next.val == val) \n                curr.next = curr.next.next;\n        // \u6ce8\u610f\uff0c\u5fc5\u987b\u8981\u6709else\uff0c\u4e0d\u7136curr\u5c31\u53d8\u7b2c\u4e8c\u4e2a\u20182\u2019\uff1b \u4f8b\u5b50\uff1a [1,2,2,1]\n            else \n                curr = curr.next;  //\u76f8\u5f53\u4e8e\u6307\u9488\u7684\u79fb\u52a8\n        return head;\n    }\n}",
            "title": "Remove Linked List Elements"
        },
        {
            "location": "/\u7ebf\u6027\u8868/Reverse Linked List/",
            "text": "/*\n206. Reverse Linked List\n\nReverse a singly linked list.\n\n#\u601d\u8def\uff1a\n        \u5c06head\u5143\u7d20\u91cc\u7684\u5404\u4e2a\u6307\u9488\u65b9\u5411\u8bbe\u4e3a\u76f8\u53cd\u53cd\u5411\uff0c\n        \u7136\u540e\u518d\u8ba9pre\u6307\u5411head\u6700\u540e\u4e00\u4e2a\u6307\u9488\u5c31\u884c\n*/\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\n\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode pre = null;\n        ListNode cur = head;\n        //\u901a\u8fc7\u6539\u53d8\u6307\u9488\u6307\u5411\n        while(cur != null ){\n            ListNode nexttemp = cur.next;\n            cur.next = pre;\n            pre = cur; //\u66f4\u65b0pre\u6307\u5411cur\n            cur = nexttemp; //\u66f4\u65b0cur\n        }\n        return pre;\n    //\u4e3a\u4ec0\u4e48\u5728\u8fd9return cur/head \u7ed3\u679c\u4e0d\u4e00\u6837\uff1a\u56e0\u4e3ahead\u6307\u5411\u7b2c\u4e00\u4e2a\u5143\u7d20\u800ccur\u6307\u5411\u6700\u540e\u4e00\u4e2a\n    }\n}\n\n\n/*\n\u518d\u6765\u4e2a\u9012\u5f52\u7b97\u6cd5\n\n\u9012\u5f52\u7248\u672c\u7a0d\u5fae\u590d\u6742\u4e00\u4e9b\uff0c\u5173\u952e\u662f\u5411\u540e\u9000\u3002\u5047\u8bbe\u5217\u8868\u7684\u5176\u4f59\u90e8\u5206\u5df2\u7ecf\u88ab\u98a0\u5012\u4e86\uff0c\u73b0\u5728\u5982\u4f55\u626d\u8f6c\u524d\u9762\u90e8\u5206\uff1f\n\u6211\u4eec\u5047\u8bbe\u5217\u8868\u662f\uff1an 1 \u2192...\u2192n k-1 \u2192n k \u2192n k + 1 \u2192...\u2192n m \u2192\u00d8\n\u4ece\u8282\u70b9n k + 1\u5230n m\u7684\u5047\u8bbe\u5df2\u7ecf\u88ab\u53cd\u8f6c\uff0c\u5e76\u4e14\u5728\u8282\u70b9n k\u5904\u3002\nn 1 \u2192...\u2192n k-1 \u2192 n k \u2192n k + 1 \u2190...\u2190n m\n\u6211\u4eec\u5e0c\u671bn k + 1\u7684\u4e0b\u4e00\u4e2a\u8282\u70b9\u6307\u5411n k\u3002\n\u6240\u4ee5\uff0cn k .next.next = n k ;\n\u8981\u5c0f\u5fc3\uff0cn 1\u7684\u4e0b\u4e00\u4e2a\u5fc5\u987b\u6307\u5411\u00d8\u3002\u5982\u679c\u60a8\u5fd8\u8bb0\u4e86\u8fd9\u4e00\u70b9\uff0c\u60a8\u7684\u94fe\u63a5\u5217\u8868\u5c31\u4f1a\u6709\u4e00\u4e2a\u5faa\u73af\u3002\n*/\n//C++\nListNode* reverseList(ListNode* head) {\n    if (head == null || head->next == null) return head;\n    ListNode* p = reverseList(head->next);\n    head->next->next = head;\n    head->next = null;\n    return p;\n}\n\n//Java\u5b9e\u73b0\npublic ListNode reverseList(ListNode head) {\n    if (head == null || head.next == null) return head;\n    ListNode p = reverseList(head.next);\n    head.next.next = head;\n    head.next = null;\n    return p;\n}",
            "title": "Reverse Linked List"
        },
        {
            "location": "/\u5b57\u7b26\u4e32/Detect Capital_toUpperCase&&substring/",
            "text": "/*\n520. Detect Capital\n\n\nGiven a word, you need to judge whether the usage of capitals in it is right or not.\nWe define the usage of capitals in a word to be right when one of the following cases holds:\nAll letters in this word are capitals, like \"USA\".\nAll letters in this word are not capitals, like \"leetcode\".\nOnly the first letter in this word is capital if it has more than one letter, like \"Google\".\nOtherwise, we define that this word doesn't use capitals in a right way.\n\n\nExample 1:\nInput: \"USA\"\nOutput: True\n\n\nExample 2:\nInput: \"FlaG\"\nOutput: False\n\n\nA: 65 a: 97 \u4e24\u8005\u76f8\u5dee32\uff0c\u5171\u670926\u4e2a\u5b57\u6bcd\n*/\n\n\n//\u76f4\u63a5\u66b4\u529b\npublic static boolean detectCapitalUse(String word) {\n    char zm[] = word.toCharArray();\n    boolean status = true;\n    if(zm.length==1)\n        return status;\n    if(zm[0] <= 'Z' && zm[1] <= 'Z') { \n        for (int i = 2; i < zm.length; i++) \n            if(zm[i] >'Z') {\n                status = false;\n                break;\n            }\n    }\n    else if(zm[0] <= 'Z' && zm[1] > 'Z') { \n        for (int i = 2; i < zm.length; i++) \n            if(zm[i] <='Z') {\n                status = false;\n                break;\n            }\n    }   \n    else if(zm[0] > 'Z') { \n        for (int i = 1; i < zm.length; i++) \n            if(zm[i] <='Z') {\n                status = false;\n                break;\n            }\n    }   \n\n    return status;\n}\n\n//\u4f7f\u7528string\u5185\u7f6e\u51fd\u6570\npublic boolean detectCapitalUse(String word) {\n    if (word.length() < 2) return true;\n    if (word.toUpperCase().equals(word)) return true;\n    if (word.substring(1).toLowerCase().equals(word.substring(1))) return true;\n    return false;\n}\n/*\nsubstring\n\u8fd4\u56de\u4e00\u4e2a\u65b0\u5b57\u7b26\u4e32\uff0c\u5b83\u662f\u6b64\u5b57\u7b26\u4e32\u7684\u4e00\u4e2a\u5b50\u5b57\u7b26\u4e32\u3002\n\u8be5\u5b50\u5b57\u7b26\u4e32\u4ece\u6307\u5b9a\u7684 beginIndex \u5904\u5f00\u59cb\uff0c\u76f4\u5230\u7d22\u5f15 endIndex - 1 \u5904\u7684\u5b57\u7b26\u3002\n\n\"hamburger\".substring(4, 8) returns \"urge\"\n*/",
            "title": "Detect Capital toUpperCase&&substring"
        },
        {
            "location": "/\u5b57\u7b26\u4e32/Judge Route Circle/",
            "text": "/*\n657. Judge Route Circle\n\n\nInitially, there is a Robot at position (0, 0). Given a sequence of its moves,\njudge if this robot makes a circle, which means it moves back to the original place.\n\n\nThe move sequence is represented by a string. And each move is represent by \na character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). \nThe output should be true or false representing whether the robot makes a circle.\n\n\nExample 1:\nInput: \"UD\"\nOutput: true\n\n\nExample 2:\nInput: \"LL\"\nOutput: false\n*/\n\n\n/*\n\u601d\u8def\uff1a\n    \u5c06\u5b57\u7b26\u4e32moves\u8f6c\u6362\u4e3a\u53ef\u62b5\u6d88\u7684\u6570\u5b57\u6570\u7ec4b[]\uff0c\u5efa\u7acbstack\uff0c\u5c06\u6570\u7ec4b[i]\u5143\u7d20\u6dfb\u52a0\u8fdb\u53bb\uff0c\n    \u8fdb\u5165\u524d\u5224\u65adstack\u662f\u5426\u5305\u542bb[i]\u7684\u76f8\u53cd\u6570-b[i]\uff0c\u6709\u7684\u8bdd\u79fb\u9664-b[i]\uff0c\u76f4\u81f3\u904d\u5386\u5b8c\u6570\u7ec4b[i]\n    \u6700\u540e\u5224\u65adstack\u662f\u5426\u4e3a\u7a7a\u3002\n*/\npublic boolean judgeCircle(String moves) {\n    //\u5c06\u5b57\u7b26\u4e32moves\u8f6c\u6362\u4e3a\u53ef\u62b5\u6d88\u7684\u6570\u5b57\u6570\u7ec4b[]\n    char []a=moves.toCharArray();\n    int []b=new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n        if(a[i]=='L')\n            b[i]=1;\n        if(a[i]=='R')\n            b[i]=-1;\n        if(a[i]=='U')\n            b[i]=2;\n        if(a[i]=='D')\n            b[i]=-2;\n    }\n    //\u5efa\u7acbstack\uff0c\u5c06\u6570\u7ec4b[i]\u5143\u7d20\u6dfb\u52a0\u8fdb\u53bb\u5e76\u5224\u65ad\n    LinkedList<Integer> stack = new LinkedList<>();\n    for (int i = 0; i < b.length; i++) {\n        if (stack.isEmpty()) \n            stack.push(b[i]);\n        else {\n            if(stack.contains(-b[i])) {\n                stack.remove(stack.indexOf(-b[i]));\n                continue;\n            }\n            stack.push(b[i]);\n        }\n    }\n    //stack\u4e3a\u7a7a\u5219true\n    if(stack.isEmpty())\n        return true;\n    else\n        return false;\n}\n\n/*\n\u4e0a\u9762\u4ee3\u7801\u52c9\u5f3a\u901a\u8fc7\uff0c\u65f6\u95f4\uff1aO(logn),\u7a7a\u95f4\u6709\u4e24\u4e2a\u6570\u7ec4+\u4e00\u4e2astack\uff0c\u663e\u7136\u6548\u7387\u592a\u4f4e\uff01\n\u5176\u5b9e\uff0c\u6211\u4eec\u53ea\u9700\u63d0\u53d6\u6700\u6838\u5fc3\u7684\u90e8\u5206\uff0c\u4e5f\u5c31\u662f\uff1aL->R \u3001 U->D\uff1b\u53ea\u8981\u6210\u5bf9\u51fa\u73b0\u5c31\u662ftrue\n*/\npublic boolean judgeCircle(String moves) {\n    int x=0,y=0;\n    for (char s : moves.toCharArray()) {\n        if(s=='L')\n            x++;\n        if(s=='R')\n            x--;\n        if(s=='U')\n            y++;\n        if(s=='D')\n            y--;\n    }\n    return x==0 && y==0;\n}",
            "title": "Judge Route Circle"
        },
        {
            "location": "/\u5b57\u7b26\u4e32/Reverse String/",
            "text": "/*\n344. Reverse String\n\n\nWrite a function that takes a string as input and returns the string reversed.\n\n\nExample:\nGiven s = \"hello\", return \"olleh\".\n*/\n\n\npublic String reverseString(String s) {\n    int len=s.length();\n    char []b=new char[len];\n    for (char a : s.toCharArray()) {\n        b[len-1] = a;\n        len--;\n    }\n    String end = new String(b);\n    return end;\n}",
            "title": "Reverse String"
        },
        {
            "location": "/\u5b57\u7b26\u4e32/Reverse Words in a String III/",
            "text": "/*\n557. Reverse Words in a String III\n\n\nGiven a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.\n\n\nExample 1:\nInput: \"Let's take LeetCode contest\"\nOutput: \"s'teL ekat edoCteeL tsetnoc\"\n*/\n\n\nclass Solution {\n    //\u7f6e\u53cd\u5355\u4e2a\u5355\u8bcd\n    public static String reverseString(String s) {\n        int len=s.length();\n        char []b=new char[len];\n        for (char a : s.toCharArray()) {\n            b[len-1] = a;\n            len--;\n        }\n        String end = new String(b);\n        return end;\n    }\n    //\u7f6e\u53cd\u6574\u6761\u5b57\u7b26\u4e32\n    public String reverseWords(String s) {\n        char a[] = s.toCharArray();\n        //\u786e\u5b9a\u5355\u4e2a\u5355\u8bcd\u4e2a\u6570\n        int count=1;\n        for (int i = 0; i < a.length; i++) \n            if(a[i]==' ')\n                count++;\n        int j=0;\n        //\u8bbe\u7f6e\u6570\u7ec4b\uff0c\u7528\u6765\u5b58\u653e\u7f6e\u53cd\u540e\u7684\u5355\u8bcd\n        String b[] = new String[count];\n        for (int i = 0; i < count; i++) {\n            b[i] = new String();\n        }\n\n        for (int i = 0; i < b.length; i++) {\n            while(j < a.length) {\n                if(a[j]==' ') {\n                    b[i] = reverseString(b[i])+\" \";\n                    j++;\n                    break;\n                }\n                b[i]+=a[j];\n                j++;\n            }\n        }\n        //\u5904\u7406\u6700\u540e\u4e00\u4e2a\u5355\u8bcd\n        b[count-1] = reverseString(b[count-1]);\n        String string = new String();\n        for (int i = 0; i < b.length; i++) \n            string+=b[i];\n\n        return string;\n    }\n}",
            "title": "Reverse Words in a String III"
        },
        {
            "location": "/\u5b57\u7b26\u4e32/Valid Palindrome II/",
            "text": "/*\n680. Valid Palindrome II\n\n\nGiven a non-empty string s, you may delete at most one character. \nJudge whether you can make it a palindrome.\n\n\nExample 1:\nInput: \"aba\"\nOutput: True\n\n\nExample 2:\nInput: \"abca\"\nOutput: True\n\n\nExplanation: You could delete the character 'c'.\n*/\n\n\n/*\n\u601d\u8def\uff1a\n    \u5229\u7528\u4e8c\u5206\u641c\u7d22\uff0c\u6bd4\u8f83\u4e24\u7aef\u503c\uff0c\u5982\u679c\u503c\u4e0d\u76f8\u7b49\uff0c\u5219if(sum[i+1]==sum[j]&&sum[i+2]==sum[j-1])\n    \u771f\u65f6\uff1a\u53f3\u8fb9\u7684\u503c\u539f\u5730\u8e0f\u6b65\n    \u5047\u65f6\uff1a\u5de6\u8fb9\u7684\u503c\u539f\u5730\u8e0f\u6b65\n    \u76f4\u81f3count\u5927\u4e8e1\n*/\n\npublic static boolean validPalindrome(String s) {\n    boolean status=true;\n    char[] sum = s.toCharArray();\n    int i =0 ,j=sum.length-1,count=0;\n    while (i<j) {\n        if(sum[i]!=sum[j]) {\n            if(sum.length<3)\n            {\n                status=true;\n                break;\n            }\n            if(sum[i+1]==sum[j]&&sum[i+2]==sum[j-1])\n                j++;\n            else\n                i--;\n\n            count++;\n            if(count>1)\n            {\n                status=false;\n                break;\n            }\n        }\n\n    i++;j--;\n    }\n  return status;\n}",
            "title": "Valid Palindrome II"
        },
        {
            "location": "/\u6808/Implement Queue using Stacks/",
            "text": "/*\n232. Implement Queue using Stacks\n\n\nImplement the following operations of a queue using stacks.\n\n\npush(x) -- Push element x to the back of queue.\npop() -- Removes the element from in front of queue.\npeek() -- Get the front element.\nempty() -- Return whether the queue is empty.\n*/\n\n\nclass MyQueue {\n    ArrayDeque< Integer> queue = new ArrayDeque<>();\n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        queue.offer(x);\n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        int e = queue.peek();\n        queue.poll();\n        return e;\n    }\n\n    /** Get the front element. */\n    public int peek() {\n        return queue.peek();\n    }\n\n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return queue.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */",
            "title": "Implement Queue using Stacks"
        },
        {
            "location": "/\u6808/Implement Stack using Queues/",
            "text": "/*\n225. Implement Stack using Queues\n\n\nImplement the following operations of a stack using queues.\n\n\n- push(x) -- Push element x onto stack.\n- pop() -- Removes the element on top of the stack.\n- top() -- Get the top element.\n- empty() -- Return whether the stack is empty.\n\n\n\nNotes:\n    - You must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid.\n    - Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.\n    - You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).\n*/\n\n\nclass MyStack {\n    private Queue<Integer> q1 = new LinkedList<>();\n    private Queue<Integer> q2 = new LinkedList<>();\n    private int top;\n\n    /** Initialize your data structure here. */\n    // public MyStack() {\n    // }\n\n    /** Push element x onto stack. */\n    public void push(int x) {\n        q1.offer(x);\n        top = x;\n    }\n\n    /** Removes the element on top of the stack and returns that element. */\n    public int pop() {\n        while (q1.size() > 1) {\n        top = q1.remove();\n        q2.add(top);\n        }\n        int e=q1.remove();\n        Queue<Integer> temp = q2;\n        q2 = q1;\n        q1 = temp;\n        return e;\n    }\n\n    /** Get the top element. */\n    public int top() {\n        return top;\n    }\n\n    /** Returns whether the stack is empty. */\n    public boolean empty() {\n        return q1.isEmpty();\n    }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack obj = new MyStack();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.top();\n * boolean param_4 = obj.empty();\n */",
            "title": "Implement Stack using Queues"
        },
        {
            "location": "/\u6808/Min Stack/",
            "text": "/*\n155. Min Stack\n\n\nDesign a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\n\npush(x) -- Push element x onto stack.\npop() -- Removes the element on top of the stack.\ntop() -- Get the top element.\ngetMin() -- Retrieve the minimum element in the stack.\nExample:\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --> Returns -3.\nminStack.pop();\nminStack.top();      --> Returns 0.\nminStack.getMin();   --> Returns -2.\n*/\n\n\n//Java\nclass MinStack {\n    Stack<Integer> stack = new Stack<Integer>();\n    Stack<Integer> stack2 = new Stack<Integer>();\n\n    public void push(int x) {\n        stack.push(x);\n        if(stack2.isEmpty() || x<=getMin())\n            stack2.push(x);\n\n\n    }\n\n    public void pop() {\n        int e = stack.pop();\n        if(e == getMin())\n            stack2.pop();\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int getMin() {\n        return stack2.peek();\n    }\n}\n\n//\u4e0b\u9762\u662f\u6548\u7387\u66f4\u9ad8\u7684c++\u4ee3\u7801\uff0c\u601d\u8def\u4e00\u6837\nclass MinStack {\nprivate:\n    stack<int> s1;\n    stack<int> s2;\npublic:\n    void push(int x) {\n        s1.push(x);\n        if (s2.empty() || x <= getMin())  s2.push(x);       \n    }\n    void pop() {\n        if (s1.top() == getMin())  s2.pop();\n        s1.pop();\n    }\n    int top() {\n        return s1.top();\n    }\n    int getMin() {\n        return s2.top();\n    }\n};",
            "title": "Min Stack"
        },
        {
            "location": "/\u6808/Next Greater Element I/",
            "text": "/*\n496. Next Greater Element I\n\n\nYou are given two arrays (without duplicates) nums1 and nums2 where nums1\u2019s elements\n are subset of nums2. Find all the next greater numbers for nums1's elements in the\n  corresponding places of nums2.\nThe Next Greater Number of a number x in nums1 is the first greater number to its \nright in nums2. If it does not exist, output -1 for this number.\n\n\n\u9898\u610f\uff1a\n\n\n\u7ed9\u5b9a\u4e24\u4e2a\u6570\u7ec4\uff08\u6ca1\u6709\u91cd\u590d\uff09nums1 \u548c nums2 ,nums1 \u662fnums2\u7684\u5b50\u96c6\u3002\n\u627e\u5230nums1\u4e2d\u6bcf\u4e2a\u5143\u7d20\u7684\u5728nums2\u4e2d\u7684\u4e0b\u4e00\u4e2a\u6bd4\u5176\u5927\u7684\u503c\u3002\nnums1\u4e2d\u7684x\u7684\u4e0b\u4e00\u4e2a\u5927\u7684\u503c\u662f\u8be5\u6570\u5b57x\u5728nums2\u4e2d\uff0c\u53f3\u8fb9\u7684\u6bd4\u5176\u5927\u7684\u4e00\u4e2a\u503c\u3002\u5982\u679c\u4e0d\u5b58\u5728\uff0c\u8fd4\u56de-1\u3002\n\n\n\n*/\n\n\n//\u76f4\u63a5\u66b4\u529b\u679a\u4e3e\npublic static int[] nextGreaterElement(int[] nums1, int[] nums2) {\n    int a[] =new int[nums1.length];\n    int k =0 ,status=0;\n\n    for (int i = 0; i < nums1.length; i++) {\n        status = 0;\n\n        for (int j = 0; j < nums2.length; j++) \n            if(nums1[i] == nums2[j]) \n                for (int j2 = j; j2 < nums2.length; j2++) \n                    if(nums2[j2] > nums1[i]) {\n                        a[k++] = nums2[j2];\n                        status = -1;\n                        break;\n                    }\n\n        if(status==0) \n            a[k++]=-1;  \n    }\n    return a;\n}",
            "title": "Next Greater Element I"
        },
        {
            "location": "/\u6808/Next Greater Element I/#_1",
            "text": "\u7ed9\u5b9a\u4e24\u4e2a\u6570\u7ec4\uff08\u6ca1\u6709\u91cd\u590d\uff09nums1 \u548c nums2 ,nums1 \u662fnums2\u7684\u5b50\u96c6\u3002\n\u627e\u5230nums1\u4e2d\u6bcf\u4e2a\u5143\u7d20\u7684\u5728nums2\u4e2d\u7684\u4e0b\u4e00\u4e2a\u6bd4\u5176\u5927\u7684\u503c\u3002\nnums1\u4e2d\u7684x\u7684\u4e0b\u4e00\u4e2a\u5927\u7684\u503c\u662f\u8be5\u6570\u5b57x\u5728nums2\u4e2d\uff0c\u53f3\u8fb9\u7684\u6bd4\u5176\u5927\u7684\u4e00\u4e2a\u503c\u3002\u5982\u679c\u4e0d\u5b58\u5728\uff0c\u8fd4\u56de-1\u3002  */  //\u76f4\u63a5\u66b4\u529b\u679a\u4e3e\npublic static int[] nextGreaterElement(int[] nums1, int[] nums2) {\n    int a[] =new int[nums1.length];\n    int k =0 ,status=0;\n\n    for (int i = 0; i < nums1.length; i++) {\n        status = 0;\n\n        for (int j = 0; j < nums2.length; j++) \n            if(nums1[i] == nums2[j]) \n                for (int j2 = j; j2 < nums2.length; j2++) \n                    if(nums2[j2] > nums1[i]) {\n                        a[k++] = nums2[j2];\n                        status = -1;\n                        break;\n                    }\n\n        if(status==0) \n            a[k++]=-1;  \n    }\n    return a;\n}",
            "title": "\u9898\u610f\uff1a"
        },
        {
            "location": "/\u6808/Next Greater Element II (System.arraycopy)/",
            "text": "/*\n503. Next Greater Element II\n\n\nGiven a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, output -1 for this number.\n\n\nExample 1:\nInput: [1,2,1]\nOutput: [2,-1,2]\nExplanation: The first 1's next greater number is 2; \nThe number 2 can't find next greater number; \nThe second 1's next greater number needs to search circularly, which is also 2.\n*/\n\n\n//\u9898\u610f\uff1a\u4ece\u6570\u7ec4\u4e2d\u4ece\u5de6\u5230\u53f3\u627e\u5230\u6bd4sum[i]\u5927\u7684\u503c\npublic static int[] nextGreaterElements(int[] nums) {\n    int []a =new int[nums.length];\n    int k = 0, status;\n\n    for (int i = 0; i < nums.length-1; i++) {\n        status = 0;\n//          \u7b2c\u4e00\u904dfor\uff0c\u7b5b\u9009sum[i]\u540e\u7684\u503c\n        for (int j = i+1; j < nums.length; j++) \n        if(nums[j] > nums[i]) {\n            status = 1;\n            a[k++] = nums[j];\n            break;\n        }\n//          \u7b2c\u4e8c\u904d\uff0c\u7b5b\u9009sum[i]\u524d\u7684\u503c\n        for (int j = 0; j < i && status==0; j++) \n            if(nums[j] > nums[i]) {\n                status = 1;\n                a[k++] = nums[j];\n                break;\n            }\n\n//          \u5982\u679c\u90fd\u627e\u4e0d\u5230\uff0c\u90a3\u5c31\u662f-1\n        if(status == 0)\n            a[k++] = -1;\n    } \n    status = 0;\n//        \u5bf9\u6700\u540e\u7684\u4e00\u4e2a\u6570\u8fdb\u884c\u5904\u7406\n    for (int i = 0; i < nums.length-1; i++) \n        if(nums[i] > nums[nums.length-1]) {\n            status = 1;\n            a[k++] = nums[i];\n            break;\n        }\n    if (status == 0 && nums.length != 0) \n        a[k++] = -1;\n\n    return a;   \n}\n\n/*\n\u4ee3\u7801\u4e0d\u591f\u7b80\u6d01\uff0c\u6211\u4f7f\u7528System.arraycopy\uff08\uff09\uff0c\u6784\u9020doublenums[]\n\u5305\u542b\u4e24\u4e2anums\u6570\u636e,\u8fd9\u6837\u5c31\u4e0d\u9700\u8981\u56de\u5934\u6765\u5224\u65ad\u6570\u7ec4\u524d\u9762\u7684\u503c\u4e86\n*/\npublic int[] nextGreaterElements(int[] nums) {\n    int []a =new int[nums.length];\n    int []doublenums = new int[2*nums.length];\n    System.arraycopy(nums, 0, doublenums, 0, nums.length);\n    System.arraycopy(nums, 0, doublenums, nums.length, nums.length);\n\n    int k = 0, status;\n    for (int i = 0; i < nums.length; i++) {\n        status = 0;\n        for (int j = i+1; j < doublenums.length; j++) \n            if(doublenums[j] > nums[i]) {\n                status = 1;\n                a[k++] = doublenums[j];\n                break;\n            }\n        if(status == 0)\n            a[k++] = -1;\n    }\n\n    return a;   \n}\n\n/*\n\u4e0a\u9762\u6548\u7387\u4e0d\u9ad8\uff0c\u7a7a\u95f4\u548c\u65f6\u95f4\u90fd\u662fO(n^2)\uff0c\u800c\u4e14\u8c03\u7528System.arraycopy\u4e5f\u4f1a\u8017\u8d39\u4e00\u4e9b\u65f6\u95f4\uff0c\n\u8ba9\u6211\u4eec\u6765\u4f18\u5316\u4e0b\uff0c\u53ef\u4ee5\u7528\u6570\u5b66\u8868\u8fbe\u5f0f j%nums.length \u6765\u4ee3\u66ffdoublenums\u7684\u4f5c\u7528\n*/\npublic int[] nextGreaterElements(int[] nums) {\n    int []a =new int[nums.length];\n\n    int k = 0, status;\n    for (int i = 0; i < nums.length; i++) {\n        status = 0;\n        for (int j = i+1; j < 2*nums.length; j++) \n            if(nums[j%nums.length] > nums[i] && j%nums.length != i ) {\n                status = 1;\n                a[k++] = nums[j%nums.length];\n                break;\n            }\n        if(status == 0)\n            a[k++] = -1;\n    }\n\n    return a;   \n}\n\n/*\n\u4e0a\u9762\u6548\u7387\u6ca1\u63d0\u9ad8\u591a\u5c11\uff0c\u53ea\u662f\u5c11\u7528\u4e86\u4e00\u4e2a\u7a7a\u95f4,\u8ba9\u6211\u4eec\u4f7f\u7528stack\u6765\u63d0\u9ad8\u6548\u7387\n#\u601d\u8def\uff1a\n    \u6784\u5efa\u6808stack\uff0cnums\u4ece i = 2*nums.length-1\uff08\u5012\u7740\u6765\uff0c\u4e5f\u662f\u96be\u60f3\u5230\u7684\u987a\u7740\u6765\u5c31\u4e0d\u884c\u4e86\uff09\n    \u5f00\u59cb\u5faa\u73af\u8fdb\u884c\u5982\u4e0b\u52a8\u4f5c\u8fdb\u6808\uff1a\n    \uff081\uff09\uff1a\u8fdb\u6808\u524d\u5224\u65adnums[i]\u662f\u5426\u5927\u4e8estack.peek()\uff0c\u6ca1\u6709\u7684\u8bdd\uff0c\n    \u5c06\u5176Next Greater Element \u8bbe\u7f6e\u4e3astack.peek()\uff0c\u7136\u540e\u5165\u6808\uff1b\n    \uff082\uff09\uff1a\u5927\u4e8e\u7684\u8bdd\uff0c\u5219stack.pop()\uff0c\u76f4\u5230\u4e0d\u5927\u4e8e\u6216\u8005\u4e3a\u7a7a\u3002\n    \u5c06\u5176Next Greater Element \u8bbe\u7f6e\u4e3astack.peek()\uff0c\u7a7a\u7740\u8bbe\u7f6e\u4e3a-1\uff0c\u7136\u540e\u5165\u6808\uff1b\n*/\n\npublic static int[] nextGreaterElements(int[] nums) {\n    int []a =new int[nums.length];\n    Stack<Integer> stack = new Stack<>();\n    for (int i = 2*nums.length-1; i > 0; i--) {\n        if(stack.isEmpty()) {\n            stack.push(nums[i%nums.length]);\n            a[i%nums.length] = -1;\n            continue;\n        }\n        if(nums[i%nums.length] < stack.peek()) {\n            a[i%nums.length] = stack.peek();\n            stack.push(nums[i%nums.length]);\n        }\n        if(nums[i%nums.length] >= stack.peek()) {\n            while(!stack.isEmpty() && nums[i%nums.length] >= stack.peek())\n                stack.pop();\n            if(stack.isEmpty())\n                a[i%nums.length] = -1;\n            else \n                a[i%nums.length] = stack.peek();\n\n            stack.push(nums[i%nums.length]);\n\n        }\n    }\n\n    return a;   \n}\n\n/*\n\u601d\u8def\u5f88\u597d\uff0c\u4f46\u662f\u5b9e\u73b0\u8fc7\u7a0b\u592a\u591aif\u8bed\u53e5\u3002\u6548\u7387\u592a\u4f4e\uff0c\u7ee7\u7eed\u6539\u8fdb\n\u5c06\u4e09\u79cd\u60c5\u51b5\u6574\u5408\uff0c\n\u5f53!stack.isEmpty() && nums[i%nums.length\u65f6\uff0c\u53ea\u6267\u884cstack.pop()\uff1b\n\u5176\u4ed6\u4e24\u79cd\u53d8\u6210\u4e00\u4e2aa>b?a:b\u8868\u8fbe\u5f0f;\n\u6700\u540e\u90fd\u6267\u884c stack.push(nums[i%nums.length]);\n*/\npublic static int[] nextGreaterElements(int[] nums) {\n    int []a =new int[nums.length];\n    Stack<Integer> stack = new Stack<>();\n    for (int i = 2*nums.length-1; i >=0; i--) {\n         while(!stack.isEmpty() && nums[i%nums.length] >= stack.peek())\n             stack.pop();\n         a[i%nums.length]=  stack.isEmpty()? -1:stack.peek();\n         stack.push(nums[i%nums.length]);\n    }\n\n    return a;   \n}",
            "title": "Next Greater Element II (System.arraycopy)"
        },
        {
            "location": "/\u6808/Simplify Path/",
            "text": "/*\n71. Simplify Path\n\n\nGiven an absolute path for a file (Unix-style), simplify it.\n\n\nFor example,\npath = \"/home/\", => \"/home\"\npath = \"/a/./b/../../c/\", => \"/c\"\n\n\n\u9898\u610f\uff1a\n\n\n\".\"\u8868\u793a\u5f53\u524d\u76ee\u5f55\uff1b \"..\"\u8868\u793a\u4e0a\u7ea7\u76ee\u5f55\n\n\n\n*/\n\n\n\nclass Solution {\n    public String simplifyPath(String path) {\n       ArrayDeque<String> stack = new ArrayDeque<>();\n        String []sum = path.split(\"/\");\n        for (int i = 0; i < sum.length; i++) \n            if(!sum[i].equals(\"\") && sum[i].equals(\"..\") && !stack.isEmpty())\n                stack.pop();\n            else if(!sum[i].equals(\"\") && !sum[i].equals(\".\") && !sum[i].equals(\"..\"))\n                stack.push(sum[i]);\n\n        String value=\"\";\n        if(stack.isEmpty())\n            value = \"/\";\n        while(!stack.isEmpty()) {\n            value = \"/\"+stack.pop()+value;\n        }\n\n        return value;\n    }\n}",
            "title": "Simplify Path"
        },
        {
            "location": "/\u6808/Simplify Path/#_1",
            "text": "\".\"\u8868\u793a\u5f53\u524d\u76ee\u5f55\uff1b \"..\"\u8868\u793a\u4e0a\u7ea7\u76ee\u5f55  */  \nclass Solution {\n    public String simplifyPath(String path) {\n       ArrayDeque<String> stack = new ArrayDeque<>();\n        String []sum = path.split(\"/\");\n        for (int i = 0; i < sum.length; i++) \n            if(!sum[i].equals(\"\") && sum[i].equals(\"..\") && !stack.isEmpty())\n                stack.pop();\n            else if(!sum[i].equals(\"\") && !sum[i].equals(\".\") && !sum[i].equals(\"..\"))\n                stack.push(sum[i]);\n\n        String value=\"\";\n        if(stack.isEmpty())\n            value = \"/\";\n        while(!stack.isEmpty()) {\n            value = \"/\"+stack.pop()+value;\n        }\n\n        return value;\n    }\n}",
            "title": "\u9898\u610f\uff1a"
        },
        {
            "location": "/\u6808/Valid Parentheses/",
            "text": "/*\n20. Valid Parentheses\n\n\nGiven a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\n\nThe brackets must close in the correct order, \"()\" and \"()[]{}\" are all valid but \"(]\" and \"([)]\" are not.\n*/\n\n\n\npublic boolean isValid(String s) {\n    char []sum=s.toCharArray();\n    LinkedList<Character> stack = new LinkedList<>();\n    for (int i = 0; i < sum.length; i++) {\n        if(stack.isEmpty())\n            stack.push(sum[i]);\n        else if(sum[i] == stack.peek()+1 || sum[i] == stack.peek()+2)\n            stack.pop();\n        else\n            stack.push(sum[i]);\n    }\n    if(stack.isEmpty())\n        return true;\n    else \n        return false;\n}",
            "title": "Valid Parentheses"
        },
        {
            "location": "/DFS/Minimum Depth of Binary Tree/",
            "text": "/*\n111. Minimum Depth of Binary Tree\n\nGiven a binary tree, find its minimum depth.\n\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n\u9898\u610f\uff1a\u6c42\u6811\u7684\u6700\u6d45\u6df1\u5ea6\n*/\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\n/*\n\u601d\u8def\uff1a\n    \u4e0e\u7b97\u6811\u7684\u6df1\u5ea6\u601d\u8def\u4e00\u6837\uff0c\u9700\u8981\u5904\u7406\u7684\u662f\u5355\u8282\u70b9\u548c\u53cc\u8282\u70b9\n    \u5355\u8282\u70b9\u65f6\uff1a \u53d6\u6700\u6df1\u5b50\u6811+1\n    \u53cc\u8282\u70b9\u65f6\uff1a \u53d6\u6700\u6d45\u5b50\u6811+1\n*/\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        if(root == NULL)\n            return 0;\n        int depl = minDepth(root->left);\n        int depr = minDepth(root->right);\n        if (root->left == NULL || root->right == NULL)\n        return (depl>depr?depl:depr)+1;\n        else {\n            if (depl < depr)\n                return depl + 1;\n            else\n                return depr + 1;\n        }\n    }\n};",
            "title": "Minimum Depth of Binary Tree"
        },
        {
            "location": "/\u9012\u5f52/Add Digits/",
            "text": "/*\n258. Add Digits\n\n\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\n\n\nFor example:\n\n\nGiven num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.\n*/\n\n\npublic int addDigits(int num) {\n    if(num < 0)\n        return num;\n    int value=0;\n    char [] sum = Integer.toString(num).toCharArray();\n    for (int i = 0; i < sum.length; i++) \n        value += (sum[i] - '0');\n\n    if(sum.length==1)\n        return value;\n    return  addDigits(value);\n}\n\n//\u6570\u5b66\u53d6\u4f59\npublic int addDigits(int num) {\n       return num==0?0:(num%9==0?9:(num%9));\n    }",
            "title": "Add Digits"
        },
        {
            "location": "/\u9012\u5f52/Invert Binary Tree/",
            "text": "/*\n226. Invert Binary Tree\n\nInvert a binary tree.\n\n     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\n\nto\n\n     4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1\n\n*/\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if(root == NULL)\n            return NULL;\n        TreeNode* item = root->left;\n        root->left = root->right;\n        root->right = item;\n        invertTree(root->left);\n        invertTree(root->right);\n        return root;\n    }\n};",
            "title": "Invert Binary Tree"
        },
        {
            "location": "/\u5176\u4ed6/A + B \u95ee\u9898/",
            "text": "A + B \u95ee\u9898 \n\n\n\u7ed9\u51fa\u4e24\u4e2a\u6574\u6570a\u548cb, \u6c42\u4ed6\u4eec\u7684\u548c, \u4f46\u4e0d\u80fd\u4f7f\u7528 + \u7b49\u6570\u5b66\u8fd0\u7b97\u7b26\u3002\n\n\n\u6837\u4f8b\n\u5982\u679c a=1 \u5e76\u4e14 b=2\uff0c\u8fd4\u56de3\n\n\npublic static int aplusb(int a, int b) {\n    while (b !=0) {//\u76f4\u5230\u4e0d\u4ea7\u751f\u8fdb\u4f4d\u7ed3\u675f\n        int _a = a ^ b;\n        int _b = (a&b)<<1;\n        a = _a ;\n        b = _b;\n    }\n    return a;\n}\n\n//\u9012\u5f52\npublic static int aplusb(int a, int b) {\n    if(a==0)\n        return b;\n    if(b==0)\n        return a;\n    int _a = a ^ b;\n    int _b = (a&b)<<1;\n    return aplusb(_a, _b);\n}",
            "title": "A + B \u95ee\u9898"
        },
        {
            "location": "/\u5176\u4ed6/Array Partition I/",
            "text": "\ufeff/*\n561. Array Partition I\n\n\nGiven an array of 2n integers, your task is to group these integers into n pairs of integer, \nsay (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n \nas large as possible.\n\n\nExample 1:\nInput: [1,4,3,2]\n\n\nOutput: 4\nExplanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).\nNote:\nn is a positive integer, which is in the range of [1, 10000].\nAll the integers in the array will be in the range of [-10000, 10000].\n\n\n\u601d\u8def\uff1a\u6392\u5e8f\u6570\u7ec4\uff0c\u53d6\u76f8\u90bb\u4e24\u4e2a\u6570\u6700\u5c0f\u503c\uff0c\u6b65\u65702\u904d\u5386\n*/\n\n\nclass Solution {\n    public int arrayPairSum(int[] nums) {\n        int sum=0;\n        Arrays.sort(nums);\n        for (int i = 1; i < nums.length; i+=2) {\n            sum += Math.min(nums[i],nums[i-1]);\n        }\n        return sum;\n    }\n}",
            "title": "Array Partition I"
        },
        {
            "location": "/\u5176\u4ed6/Baseball Game/",
            "text": "/*\n682. Baseball Game\n\n\nYou're now a baseball game point recorder.\nGiven a list of strings, each string can be one of the 4 following types:\nInteger (one round's score): Directly represents the number of points you get in this round.\n\"+\" (one round's score): Represents that the points you get in this round are the sum of the last two valid round's points.\n\"D\" (one round's score): Represents that the points you get in this round are the doubled data of the last valid round's points.\n\"C\" (an operation, which isn't a round's score): Represents the last valid round's points you get were invalid and should be removed.\nEach round's operation is permanent and could have an impact on the round before and the round after.\n\n\nYou need to return the sum of the points you could get in all the rounds.\n\n\nExample 1:\nInput: [\"5\",\"2\",\"C\",\"D\",\"+\"]\nOutput: 30\nExplanation: \nRound 1: You could get 5 points. The sum is: 5.\nRound 2: You could get 2 points. The sum is: 7.\nOperation 1: The round 2's data was invalid. The sum is: 5.\n\nRound 3: You could get 10 points (the round 2's data has been removed). The sum is: 15.\nRound 4: You could get 5 + 10 = 15 points. The sum is: 30.\n\n\nExample 2:\nInput: [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\nOutput: 27\nExplanation: \nRound 1: You could get 5 points. The sum is: 5.\nRound 2: You could get -2 points. The sum is: 3.\nRound 3: You could get 4 points. The sum is: 7.\nOperation 1: The round 3's data is invalid. The sum is: 3.\n\nRound 4: You could get -4 points (the round 3's data has been removed). The sum is: -1.\nRound 5: You could get 9 points. The sum is: 8.\nRound 6: You could get -4 + 9 = 5 points. The sum is 13.\nRound 7: You could get 9 + 5 = 14 points. The sum is 27.\n\n\nNote:\nThe size of the input list will be between 1 and 1000.\nEvery integer represented in the list will be between -30000 and 30000.\n\n\n\u601d\u8def\uff1a\u5176\u5b9e\u5f88\u7b80\u5355\uff0c\u53ea\u8981\u641e\u6e05\u695a\u9898\u610f\u5373\u53ef\uff1b\u5efa\u7acb\u6570\u7ec4sum\u7528\u6765\u5b58\u50a8\u6700\u540e\u6dfb\u52a0\u7684\u6570\u5b57\uff0c\u6700\u540e\u904d\u5386sum\u7edf\u8ba1\u548c\u5373\u53ef\n*/\n\n\npublic int calPoints(String[] ops) {\n    int []sum = new int[ops.length];\n    int k = 0,sums =0;\n    for (int i = 0; i < ops.length; i++) {\n        if (ops[i].equals(\"+\")) {\n            sum[k] = sum[k-1] + sum[k-2];\n            k++;\n        }\n        else if (ops[i].equals(\"D\")) {\n            sum[k] = 2 * sum[k-1];\n            k++;\n        }\n        else if (ops[i].equals(\"C\")) {\n            k --;\n            sum[k] = 0;\n        }\n        else \n            sum[k++] = Integer.parseInt(ops[i]);\n\n    }\n\n    for (int i = 0; i < sum.length; i++) \n            sums += sum[i];\n\n    return sums;\n}\n\n\n//\u5229\u7528\u6808,\u4e0a\u9762\u7684\u601d\u8def\u5176\u5b9e\u62bd\u8c61\u51fa\u6765\u5c31\u662f\u6808\npublic int calPoints(String[] ops) {\n    LinkedList<Integer> stack = new LinkedList<>();\n    int a,b,sum=0;\n    for (int i = 0; i < ops.length; i++) {\n        if (ops[i].equals(\"+\")) {\n            a = stack.pop();\n            b = stack.pop();\n            stack.push(b);\n            stack.push(a);\n            stack.push(a+b);\n        }\n        else if (ops[i].equals(\"D\")) {\n            a = stack.pop();\n            stack.push(a);\n            stack.push(2*a);\n        }\n        else if (ops[i].equals(\"C\")) {\n            stack.pop();\n        }\n        else \n            stack.push(Integer.parseInt(ops[i]));\n\n    }\n    while(!stack.isEmpty())\n        sum += stack.pop();\n    return sum;\n}\n\n//\u53ef\u4ee5\u770b\u51fa\uff0c\u6548\u7387\u6ca1\u6709\u6570\u7ec4\u9ad8\uff0c\u601d\u8def\u4e5f\u5dee\u4e0d\u591a\uff0c\u5f53\u7136\u6808\u6709\u4e2a\u597d\u5904\u5c31\u662f\u4e0d\u7528\u5904\u7406\u4e0b\u6807",
            "title": "Baseball Game"
        },
        {
            "location": "/\u5176\u4ed6/Can Place Flowers/",
            "text": "\ufeff/*\n605. Can Place Flowers\n\n\nSuppose you have a long flowerbed in which some of the plots are planted and some are not. However, \nflowers cannot be planted in adjacent plots - they would compete for water and both would die.\nGiven a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty),\nand a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.\n\n\nExample 1:\nInput: flowerbed = [1,0,0,0,1], n = 1\nOutput: True\nExample 2:\nInput: flowerbed = [1,0,0,0,1], n = 2\nOutput: False\nNote:\nThe input array won't violate no-adjacent-flowers rule.\nThe input array size is in the range of [1, 20000].\nn is a non-negative integer which won't exceed the input array size.\n\n\n*/\n\n\n/*\n\u6bd4\u8f83\u5f53\u524d\u4f4d\u7f6e\u5de6\u53f3\u4e24\u8fb9\u7684\u6570\u662f\u5426\u4e3a0\u4e14\u5f53\u524d\u4f4d\u7f6e\u662f0\uff0c\u662fcount++\uff1b\n\u4f46\u6700\u91cd\u8981\u7684\u662f\u5904\u7406\u597d\u9996\u5c3e\u4e24\u7aef\uff0ceg\uff1a[0,0,1,0,0];\u4ee5\u53ca\u5f53len<=3\u7684\u60c5\u51b5\n*/\n\nclass Solution {\n    public boolean canPlaceFlowers(int[] flowerbed, int n) {\n        int count=0,len=flowerbed.length;\n     //\u5904\u7406len<=3 and \u9996\u5c3e\u4e24\u7aef \u7684\u60c5\u51b5\n        if (len==1 && flowerbed[0]==0) {\n            return 1>=n;\n        }\n        if (len==1 && flowerbed[0]==1) {\n            return 0>=n;\n        }\n\n        if (flowerbed[0]==0 && flowerbed[1]==0) \n        {   \n            count++;\n            flowerbed[0]=1;\n        }\n        if (flowerbed[len-1]==0 && flowerbed[len-2]==0) \n        {   \n            count++;\n            flowerbed[len-1]=1;\n        }\n    //len>=3 \u7684\u60c5\u51b5\n        for (int i =1; i < len-1 && len>=3; i++) {\n            if(flowerbed[i-1]==0 && flowerbed[i+1]==0 && flowerbed[i]==0)\n            {   \n                flowerbed[i]=1; \n                count++;\n            }\n        }\n\n    return count>=n;\n    }\n}",
            "title": "Can Place Flowers"
        },
        {
            "location": "/\u5176\u4ed6/Find All Numbers Disappeared in an Array/",
            "text": "\ufeff/*\n448. Find All Numbers Disappeared in an Array\n\n\nGiven an array of integers where 1 \u2264 a[i] \u2264 n (n = size of array), \nsome elements appear twice and others appear once.\nFind all the elements of [1, n] inclusive that do not appear in this array.\nCould you do it without extra space and in O(n) runtime?\nYou may assume the returned list does not count as extra space.\n\n\nExample:\n\n\nInput:\n[4,3,2,7,8,2,3,1]\n\n\nOutput:\n[5,6]\n\n\n*/\n//\u4ee5\u4e0b\u662f\u4e24\u4e2a\u53c2\u8003\u4ee3\u7801\uff0c\u5f88\u597d\u5947\u4ed6\u4eec\u662f\u600e\u4e48\u60f3\u51fa\u8fd9\u79cd\u65b9\u6cd5\uff1f\uff0c\u597d\u597d\u601d\u8003\uff0c\u5b66\u4e60\u4e00\u4e0b\n\n\n/*\n      * The basic idea is that we iterate through the input array and mark \n      * elements as negative using nums[nums[i] -1] = -nums[nums[i]-1]. \n      * In this way all the numbers that we have seen will be marked as negative.\n      *  In the second iteration, if a value is not marked as negative, \n      *  it implies we have never seen that index before, \n      *  so just add it to the return list.\n      * */\n\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n         List<Integer> ret = new ArrayList<Integer>();\n\n        for(int i = 0; i < nums.length; i++) {\n            int val = Math.abs(nums[i]) - 1;\n            if(nums[val] > 0) {\n                nums[val] = -nums[val];\n            }\n        }\n\n        for(int i = 0; i < nums.length; i++) {\n            if(nums[i] > 0) {\n                ret.add(i+1);\n            }\n        }\n        return ret;\n    }\n\n//5-line Java Easy-understanding\n\npublic List<Integer> findDisappearedNumbers(int[] nums) {\n        List<Integer> res = new ArrayList<>();\n        int n = nums.length;\n        for (int i = 0; i < nums.length; i ++) nums[(nums[i]-1) % n] += n;  //a % b\u5982\u679ca<b,\u4f59\u6570\u662f\u5b83\u81ea\u5df1a\n        for (int i = 0; i < nums.length; i ++) if (nums[i] <= n) res.add(i+1);\n        return res;\n    }",
            "title": "Find All Numbers Disappeared in an Array"
        },
        {
            "location": "/\u5176\u4ed6/Find Pivot Index/",
            "text": "/*\n724. Find Pivot Index\n\n\nGiven an array of integers nums, write a method that returns the \"pivot\" index of this array.\n\n\nWe define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.\n\n\nIf no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.\n\n\nExample 1:\nInput: \nnums = [1, 7, 3, 6, 5, 6]\nOutput: 3\nExplanation: \nThe sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.\nAlso, 3 is the first index where this occurs.\nExample 2:\nInput: \nnums = [1, 2, 3]\nOutput: -1\nExplanation: \nThere is no index that satisfies the conditions in the problem statement.\n\n\n\u9898\u610f\uff1a\n\n\n\u5927\u6982\u5c31\u662f\u8bf4\u627e\u5230\u4e00\u4e2a\u7d22\u5f15\u4f7f\u5f97\u6570\u7ec4\u4e24\u8fb9\u548c\u76f8\u7b49\n\n\n\n*/\n\n\n//\u6211\u539f\u5148\u601d\u8def\u662f\u6253\u7b97\u7528\u7c7b\u4f3c\u4e8e\u4e8c\u5206\u67e5\u627e\u65b9\u5f0f\u6bd4\u8f83\u5f97\u51fa\uff0c\u4f46\u7ed3\u679c\u662f\u9519\u7684\uff0c\u56e0\u4e3a\u4e0d\u80fd\u6982\u62ec\u6240\u6709\u6570\u7ec4\u503c\npublic static int pivotIndex(int[] nums) {\n    int sum1=nums[0],sum2=nums[nums.length-1];\n    int i=1,j=nums.length-2;\n    while(i<=j) {\n        if(sum1==sum2)\n            break;\n        if(sum1<sum2)\n            sum1+=nums[i++];\n        if(sum1>sum2)\n            sum2+=nums[j--];\n    }\n    if(i<=j)\n        return i;\n    else\n        return -1;\n}\n//leetcode\u7684\u89e3\npublic int pivotIndex(int[] nums) {\n  int sum=0,leaftsum=0;\n    for(int x : nums)\n        sum+=x;\n    for (int i = 0; i < nums.length; i++) {\n        if(leaftsum==sum-leaftsum-nums[i])\n            return i;\n        leaftsum+=nums[i];\n    }\n    return -1;\n}",
            "title": "Find Pivot Index"
        },
        {
            "location": "/\u5176\u4ed6/Find Pivot Index/#_1",
            "text": "\u5927\u6982\u5c31\u662f\u8bf4\u627e\u5230\u4e00\u4e2a\u7d22\u5f15\u4f7f\u5f97\u6570\u7ec4\u4e24\u8fb9\u548c\u76f8\u7b49  */  //\u6211\u539f\u5148\u601d\u8def\u662f\u6253\u7b97\u7528\u7c7b\u4f3c\u4e8e\u4e8c\u5206\u67e5\u627e\u65b9\u5f0f\u6bd4\u8f83\u5f97\u51fa\uff0c\u4f46\u7ed3\u679c\u662f\u9519\u7684\uff0c\u56e0\u4e3a\u4e0d\u80fd\u6982\u62ec\u6240\u6709\u6570\u7ec4\u503c\npublic static int pivotIndex(int[] nums) {\n    int sum1=nums[0],sum2=nums[nums.length-1];\n    int i=1,j=nums.length-2;\n    while(i<=j) {\n        if(sum1==sum2)\n            break;\n        if(sum1<sum2)\n            sum1+=nums[i++];\n        if(sum1>sum2)\n            sum2+=nums[j--];\n    }\n    if(i<=j)\n        return i;\n    else\n        return -1;\n}\n//leetcode\u7684\u89e3\npublic int pivotIndex(int[] nums) {\n  int sum=0,leaftsum=0;\n    for(int x : nums)\n        sum+=x;\n    for (int i = 0; i < nums.length; i++) {\n        if(leaftsum==sum-leaftsum-nums[i])\n            return i;\n        leaftsum+=nums[i];\n    }\n    return -1;\n}",
            "title": "\u9898\u610f\uff1a"
        },
        {
            "location": "/\u5176\u4ed6/K-diff Pairs in an Array/",
            "text": "\ufeff/*\n532. K-diff Pairs in an Array\n\n\nGiven an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array.\nHere a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.\n\n\nExample 1:\nInput: [3, 1, 4, 1, 5], k = 2\nOutput: 2\nExplanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).\nAlthough we have two 1s in the input, we should only return the number of unique pairs.\nExample 2:\nInput:[1, 2, 3, 4, 5], k = 1\nOutput: 4\nExplanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).\nExample 3:\nInput: [1, 3, 1, 5, 4], k = 0\nOutput: 1\nExplanation: There is one 0-diff pair in the array, (1, 1).\nNote:\nThe pairs (i, j) and (j, i) count as the same pair.\nThe length of the array won't exceed 10,000.\nAll the integers in the given input belong to the range: [-1e7, 1e7].\n*/\n\n\npublic int findPairs(int[] nums, int k) {\n    Arrays.sort(nums);\n    int pairs=0;\n    int [] sum =new int [nums.length];\n    for (int i = 1; i < nums.length; i++) \n        sum[i] = nums[i] - nums[i-1];\n\n\n    if (k==0) {\n        for (int i = 1; i < nums.length-1; i++) {\n            if(i==nums.length-2 && sum[i+1]==0)\n                ++pairs;\n            if(sum[i]==sum[i+1]) \n                continue;\n\n\n            if (sum[i]==0) \n                ++pairs;\n\n        }\n        if(nums.length==2 && sum[1]==0) pairs=1;\n\n    }else {\n        for (int i = 0; i < nums.length-1; i++) {\n            if(nums[i]==nums[i+1]) \n                continue;\n\n            for (int j = i+1; j < nums.length; j++) \n                if (Math.abs(nums[i] - nums[j]) == k) {\n                    ++pairs;\n                    break;\n                }\n\n        }\n    }\n\n\n    return pairs;\n}\n//k==0\u65f6\u7684\u4e0d\u540c\u89e3\u6cd5\nclass Solution {\n    public int findPairs(int[] nums, int k) {\n        Arrays.sort(nums);\n        int pairs=0;\n\n        if(nums.length <2)\n            return 0;\n        if (k==0) {\n            int i=0,count=0,sta = nums[0];\n            if(nums[1]==nums[0])\n                count = 1;\n            while(i < nums.length-1){\n                if(nums[i] == nums[i+1] && nums[i] != sta){\n                    sta=nums[i];\n                    count++;\n                    i++;\n                }\n                i++;\n            }\n\n            pairs = count;\n        }else {\n            for (int i = 0; i < nums.length-1; i++) {\n                if(nums[i]==nums[i+1]) \n                    continue;\n\n                for (int j = i+1; j < nums.length; j++) \n                    if (Math.abs(nums[i] - nums[j]) == k) {\n                        ++pairs;\n                        break;\n                    }\n\n            }\n        }\n\n\n        return pairs;\n}\n}",
            "title": "K diff Pairs in an Array"
        },
        {
            "location": "/\u5176\u4ed6/Longest Continuous Increasing Subsequence/",
            "text": "/*\n674. Longest Continuous Increasing Subsequence\n\n\nGiven an unsorted array of integers, find the length of longest continuous increasing subsequence.\n\n\nExample 1:\nInput: [1,3,5,4,7]\nOutput: 3\nExplanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. \nEven though [1,3,5,7] is also an increasing subsequence, it's not a continuous one where 5 and 7 are separated by 4. \nExample 2:\nInput: [2,2,2,2,2]\nOutput: 1\nExplanation: The longest continuous increasing subsequence is [2], its length is 1. \nNote: Length of the array will not exceed 10,000.\n*/\n\n\n/\n\nIntuition:\n    \u8ba1\u7b97\u76f8\u90bb\u7684\u5dee\uff0c\u5982\u679c\u5927\u4e8e0\uff0c\u524d\u8fdb\u76f4\u81f3\u9047\u5230\u5c0f\u4e8e0\uff0c\u8bb0\u5f55\u957f\u5ea6\uff0c\u4ee5\u6b64\u7c7b\u63a8\uff0c\u904d\u5386\u5b8c\u6570\u7ec4\uff0clen = max(len, i)\uff1b\n\n/\n\n\n\npublic int findLengthOfLCIS(int[] nums) {\n   //\u6784\u9020\u6570\u7ec4sum\uff0c\u7528\u4e8e\u5b58\u653e\u6570\u7ec4nums\u7684\u5dee\u503c\n    int []sum = new int[nums.length+1];\n    int []max_num = new int[nums.length];\n    for (int i = 1; i < nums.length; i++) {\n        sum[i] = nums[i]  - nums[i-1];\n    }\n    //\u5bf9\u6570\u7ec4sum\u64cd\u4f5c\n    int len = 0, j = 0, status=0;\n    for (int i = 1; i < nums.length; i++) {\n        if(sum[i] > 0) \n            len++;\n        else {\n            max_num[++j] = len;\n            len = 0;\n        }       \n    }\n\n    //\u904d\u5386\u627e\u51fa\u6700\u5927\u5b50\u5e8f\u5217\u957f\u5ea6\n    for (int i = 0; i < max_num.length; i++) {\n        len = Math.max(max_num[i],len);\n    }\n    if(nums.length <= 0)\n        len = -1;\n    return len+1;\n}    \n\n\n\n//\u4e0a\u9762\u4ee3\u7801\u7a7a\u95f4\u5360\u7528\u592a\u591a\uff0c\u5220\u6389\u6570\u7ec4sum\u548cmax_num\uff0c\u76f4\u63a5\u5728nums\u64cd\u4f5c\n\npublic static int findLengthOfLCIS(int[] nums) {\n //\u64cd\u4f5c\u6570\u7ec4nums\uff0c\u5c06\u76f8\u90bb\u7684\u5dee\u503c\u5b58\u50a8\u5728i-1\n     for (int i = 1; i < nums.length; i++) {\n      nums[i-1] = nums[i]  - nums[i-1];\n   }\n\n     int max_len=0,len = 0;\n     for (int i = 0; i < nums.length-1; i++) {\n      if(nums[i] > 0) \n         len++;\n      else {\n         max_len = Math.max(max_len, len);\n         len = 0;\n      }     \n   }\n\n     max_len = Math.max(max_len, len);\n     if(nums.length <= 0)\n      max_len = -1;\n\n     return max_len+1;\n}",
            "title": "Longest Continuous Increasing Subsequence"
        },
        {
            "location": "/\u5176\u4ed6/Majority Element/",
            "text": "/*\n169. Majority Element\n\n\nGiven an array of size n, find the majority element. \nThe majority element is the element that appears more than \u230a n/2 \u230b times.\n\n\nYou may assume that the array is non-empty and the majority element always\n exist in the array.\n\n\n\u601d\u8def\uff1a\n\n\n\u5229\u7528set\u5148\u8fc7\u6ee4\u6389\u91cd\u590d\u5143\u7d20\u5e76\u5c06set\u8f6c\u6362\u4e3a\u6570\u7ec4a[]\uff0c\u4e24\u5c42for\u5faa\u73af\u7edf\u8ba1\u6570\u7ec4a[]\u5404\u5143\u7d20\u51fa\u73b0\n\u6b21\u6570\uff0c\u6700\u540e\u627e\u51fa\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u5143\u7d20\u5373\u53ef\n\n\n\n*/\n\n\npublic int majorityElement(int[] nums) {\n    //\u5229\u7528set\u5148\u8fc7\u6ee4\u6389\u91cd\u590d\u5143\u7d20\u5e76\u5c06set\u8f6c\u6362\u4e3a\u6570\u7ec4a[]\n    Set<Integer> set = new LinkedHashSet<>();\n    for (int i = 0; i < nums.length; i++) \n        set.add(nums[i]);\n    Integer []a = new Integer[set.size()];\n    set.toArray(a);\n    //\u4e24\u5c42for\u5faa\u73af\u7edf\u8ba1\u6570\u7ec4a[]\u5404\u5143\u7d20\u51fa\u73b0\u6b21\u6570\n    int k=0,z=0;\n    int []sum = new int[set.size()];\n    for (int i = 0; i < a.length; i++) {\n         k=0;\n        for (int j = 0; j < nums.length; j++) \n            if (a[i] == nums[j]) \n                k++;\n         sum[z++] = k;\n    }\n    //\u6700\u540e\u627e\u51fa\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u5143\u7d20\u5e76return\n    int value=0;\n    for (int i = 0; i < sum.length; i++) \n        if(sum[i]>value) {\n            value = sum[i];\n            z = i;\n        }\n    return a[z];  \n}\n\n\n\n\n/*\n\u4e0b\u9762\u662f\u83b7\u8d5e\u6700\u591a\u7684\u4ee3\u7801\n\n\n\u601d\u8def\uff1a\n\n\n\u5148\u628amajor\u8bbe\u7f6e\u4e3anum[0]\uff0c\u904d\u5386\u6bd4\u8f83\u662f\u5426\u7b49\u4e8emajor\n\u662f\u7684\uff0ccount++\uff1b\u5426\u5219count--\uff0c\u5982\u679ccount==0\uff0c\n\u8bf4\u660enum[i]\u51fa\u73b0\u6b21\u6570\u5927\u4e8e\u539f\u5148\u7684major\uff0c\u6240\u4ee5\u66ff\u6362\n\n\n\n*/ \n\n\npublic int majorityElement(int[] num) {\n    int major=num[0], count = 1;\n    for(int i=1; i<num.length;i++){\n        if(count==0){\n            count++;\n            major=num[i];\n        }else if(major==num[i]){\n            count++;\n        }else count--;\n\n    }\n    return major;\n}",
            "title": "Majority Element"
        },
        {
            "location": "/\u5176\u4ed6/Majority Element/#_1",
            "text": "\u5229\u7528set\u5148\u8fc7\u6ee4\u6389\u91cd\u590d\u5143\u7d20\u5e76\u5c06set\u8f6c\u6362\u4e3a\u6570\u7ec4a[]\uff0c\u4e24\u5c42for\u5faa\u73af\u7edf\u8ba1\u6570\u7ec4a[]\u5404\u5143\u7d20\u51fa\u73b0\n\u6b21\u6570\uff0c\u6700\u540e\u627e\u51fa\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u5143\u7d20\u5373\u53ef  */  public int majorityElement(int[] nums) {\n    //\u5229\u7528set\u5148\u8fc7\u6ee4\u6389\u91cd\u590d\u5143\u7d20\u5e76\u5c06set\u8f6c\u6362\u4e3a\u6570\u7ec4a[]\n    Set<Integer> set = new LinkedHashSet<>();\n    for (int i = 0; i < nums.length; i++) \n        set.add(nums[i]);\n    Integer []a = new Integer[set.size()];\n    set.toArray(a);\n    //\u4e24\u5c42for\u5faa\u73af\u7edf\u8ba1\u6570\u7ec4a[]\u5404\u5143\u7d20\u51fa\u73b0\u6b21\u6570\n    int k=0,z=0;\n    int []sum = new int[set.size()];\n    for (int i = 0; i < a.length; i++) {\n         k=0;\n        for (int j = 0; j < nums.length; j++) \n            if (a[i] == nums[j]) \n                k++;\n         sum[z++] = k;\n    }\n    //\u6700\u540e\u627e\u51fa\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u5143\u7d20\u5e76return\n    int value=0;\n    for (int i = 0; i < sum.length; i++) \n        if(sum[i]>value) {\n            value = sum[i];\n            z = i;\n        }\n    return a[z];  \n}  /*\n\u4e0b\u9762\u662f\u83b7\u8d5e\u6700\u591a\u7684\u4ee3\u7801",
            "title": "\u601d\u8def\uff1a"
        },
        {
            "location": "/\u5176\u4ed6/Majority Element/#_2",
            "text": "\u5148\u628amajor\u8bbe\u7f6e\u4e3anum[0]\uff0c\u904d\u5386\u6bd4\u8f83\u662f\u5426\u7b49\u4e8emajor\n\u662f\u7684\uff0ccount++\uff1b\u5426\u5219count--\uff0c\u5982\u679ccount==0\uff0c\n\u8bf4\u660enum[i]\u51fa\u73b0\u6b21\u6570\u5927\u4e8e\u539f\u5148\u7684major\uff0c\u6240\u4ee5\u66ff\u6362  */   public int majorityElement(int[] num) {\n    int major=num[0], count = 1;\n    for(int i=1; i<num.length;i++){\n        if(count==0){\n            count++;\n            major=num[i];\n        }else if(major==num[i]){\n            count++;\n        }else count--;\n\n    }\n    return major;\n}",
            "title": "\u601d\u8def\uff1a"
        },
        {
            "location": "/\u5176\u4ed6/Max Consecutive Ones/",
            "text": "/*\n485. Max Consecutive Ones\n\n\nGiven a binary array, find the maximum number of consecutive 1s in this array.\n\n\nExample 1:\nInput: [1,1,0,1,1,1]\nOutput: 3\nExplanation: The first two digits or the last three digits are consecutive 1s.\n    The maximum number of consecutive 1s is 3.\n\n\nNote:\nThe input array will only contain 0 and 1.\nThe length of input array is a positive integer and will not exceed 10,000\n\n\n*/\n\n\n/*\nIntuition:\n    int max_num =0\uff0cvalue=0;\n\u904d\u5386\u6570\u7ec4\uff0c\u5982\u679c\u5143\u7d20\u503c\u662f1\uff0c++value\uff1b\u5426\u5219max_num=max(value,max_num) and value=0;\u904d\u5386\u7ed3\u675f\u540e\uff0cmax_num\u5c31\u662f\u7ed3\u679c\n*/\n\npublic int findMaxConsecutiveOnes(int[] nums) {\n    int max_num =0,value=0;\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i]==1) {\n            ++value;\n        }else {\n            max_num=Math.max(value,max_num);\n            value=0;\n        }\n    }\n    max_num=Math.max(value,max_num);\n    return max_num;\n}",
            "title": "Max Consecutive Ones"
        },
        {
            "location": "/\u5176\u4ed6/Maximum Average Subarray I/",
            "text": "\ufeff/*\n643. Maximum Average Subarray I\n\n\nGiven an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. \nAnd you need to output the maximum average value.\n\n\nExample 1:\nInput: [1,12,-5,-6,50,3], k = 4\nOutput: 12.75\nExplanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75\nNote:\n1 <= k <= n <= 30,000.\nElements of the given array will be in the range [-10,000, 10,000].\n*/\n\n\n//\u9898\u610f\u5927\u81f4\u662f\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e3an\u7684\u6570\u7ec4\u4ee5\u53cak\uff0c\u6c42\u6700\u5927\u7684\u8fde\u7eed\u5b50\u6570\u7ec4\u7684\u5e73\u5747\u503c\u3002\n//(1)\u4e0b\u9762\u7684\u4ee3\u7801\u601d\u8def\u662f\u5bf9\u7684\uff0c\u4f46\u662f\u8fd0\u884c\u6570\u636e\u5f88\u591a\u7684\u6570\u7ec4\u4f1a\u8d85\u65f6\uff0c\u6548\u7387\u4e0d\u9ad8\nclass Solution {\n    public double findMaxAverage(int[] nums, int k) {\n       int len=nums.length;\n        int j=1;//\u7528\u4e8e\u523b\u5ea6k\u7684\u79fb\u52a8\n        double sum1=0;\n\n        for (int i =0; i < k; i++) {\n            sum1+=nums[i];\n        }\n        double value=sum1;\n        sum1=0;\n\n        while(k+j<=len) {\n        for (int i =j; i < k+j; i++) {\n            sum1+=nums[i];\n        }\n        value=Math.max(value,sum1);\n        sum1=0;\n        ++j;\n     } \n        return value/k;\n    }\n}\n\n//(2)\u4e0b\u9762\u662f(1)\u4ee3\u7801\u7684\u7b80\u6d01\u9ad8\u6548\u7248\npublic class Solution {\n    public double findMaxAverage(int[] nums, int k) {\n        int[] sum = new int[nums.length];\n        sum[0] = nums[0];\n        for (int i = 1; i < nums.length; i++)\n        sum[i] = sum[i - 1] + nums[i];\n        double res = sum[k - 1] * 1.0 / k;\n        for (int i = k; i < nums.length; i++) {\n            res = Math.max(res, (sum[i] - sum[i - k]) * 1.0 / k);\n        }\n        return res;\n    }\n}",
            "title": "Maximum Average Subarray I"
        },
        {
            "location": "/\u5176\u4ed6/Maximum Product of Three Numbers/",
            "text": "\ufeff/*\n628. Maximum Product of Three Numbers\n\n\nGiven an integer array, find three numbers whose product is maximum and output \nthe maximum product.\n\n\nExample 1:\nInput: [1,2,3]\nOutput: 6\nExample 2:\nInput: [1,2,3,4]\nOutput: 24\nNote:\nThe length of the given array will be in range [3,104] and all elements are in \nthe range [-1000, 1000].\nMultiplication of any three numbers in the input won't exceed the range of 32-bit \nsigned integer.\n*/\n\n\n//\u601d\u8def\u5176\u5b9e\u5f88\u7b80\u5355\uff0c\u5c06\u6570\u7ec4\u6392\u597d\u5e8f\uff0c\u6bd4\u8f83sum1\u548csum2\u5c31\u884c\nclass Solution {\n    public int maximumProduct(int[] nums) {\n        int len=nums.length;\n        Arrays.sort(nums);\n        int sum1=nums[0]*nums[1]*nums[len-1];\n        int sum2=nums[len-1]*nums[len-2]*nums[len-3];\n        int maxnum=Math.max(sum1,sum2);\n        return maxnum;\n    }\n}",
            "title": "Maximum Product of Three Numbers"
        },
        {
            "location": "/\u5176\u4ed6/Maximum Subarray/",
            "text": "/*\n53. Maximum Subarray\n\n\nFind the contiguous subarray within an array (containing at least one number) which has the largest sum.\n\n\nFor example, given the array [-2,1,-3,4,-1,2,1,-5,4],\nthe contiguous subarray [4,-1,2,1] has the largest sum = 6.\n\n\nthis problem was discussed by Jon Bentley (Sep. 1984 Vol. 27 No. 9 Communications of the ACM P885)\n\n\nthe paragraph below was copied from his paper (with a little modifications)\n*/\n\n\npublic static int maxSubArray(int[] A) {\n    int maxSoFar=A[0], maxEndingHere=A[0];\n    for (int i=1;i<A.length;++i){\n        maxEndingHere= Math.max(maxEndingHere+A[i],A[i]);\n        maxSoFar=Math.max(maxSoFar, maxEndingHere); \n    }\n    return maxSoFar;\n}",
            "title": "Maximum Subarray"
        },
        {
            "location": "/\u5176\u4ed6/Maximum Subarray/#this-problem-was-discussed-by-jon-bentley-sep-1984-vol-27-no-9-communications-of-the-acm-p885",
            "text": "the paragraph below was copied from his paper (with a little modifications)\n*/  public static int maxSubArray(int[] A) {\n    int maxSoFar=A[0], maxEndingHere=A[0];\n    for (int i=1;i<A.length;++i){\n        maxEndingHere= Math.max(maxEndingHere+A[i],A[i]);\n        maxSoFar=Math.max(maxSoFar, maxEndingHere); \n    }\n    return maxSoFar;\n}",
            "title": "this problem was discussed by Jon Bentley (Sep. 1984 Vol. 27 No. 9 Communications of the ACM P885)"
        },
        {
            "location": "/\u5176\u4ed6/Maximum Swap/",
            "text": "/*\n670. Maximum Swap\n\n\nGiven a non-negative integer, you could swap two digits at most once to get the maximum valued number. \nReturn the maximum valued number you could get.\n\n\nExample 1:\nInput: 2736\nOutput: 7236\nExplanation: Swap the number 2 and the number 7.\n\n\nExample 2:\nInput: 9973\nOutput: 9973\nExplanation: No swap.\n\n\nNote:\nThe given number is in the range [0, 108]\n*/\n\n\n/*\nIntuition:\n   \u904d\u5386\u6570\u7ec4\uff0c\u627e\u51faA[i]\u540e\u7684\u6700\u5927\u503cmax_num\uff0c\u4ee5\u53camax_num\u6700\u540e\u51fa\u73b0\u7684\u4e0b\u6807index\uff0cif(max_num > A[i] && A[i] != max_num),\n   \u90a3\u4e48\u5c31\u4ea4\u6362\u4e24\u8005\uff0c\u5e76\u9000\u51fa\u5faa\u73af\uff0c\u5426\u5219\u7ee7\u7eed\u904d\u5386\u6570\u7ec4\u3002\n*/\n\npublic int maximumSwap(int num) {\n    char[] A = Integer.toString(num).toCharArray();\n     int index=0;\n     char max_num ='0',value;\n     for (int i = 0; i < A.length-1; i++) { //i<A.length-1\n         //\u627e\u51faA[i]\u540e\u9762\u7684\u6700\u5927\u503c\n         for (int j = i+1; j < A.length; j++) \n             max_num = (char) Math.max(max_num, A[j]);\n         //\u627e\u51fa\u6700\u5927\u503c\u4e0b\u6807      \n         for (int j2 = i+1; j2 < A.length; j2++) \n             if(A[j2] == max_num)\n                 index = j2;\n         //\u4e0a\u9762\u7684\u6700\u5927\u503c\u548c\u4e0b\u6807\u90fd\u5df2\u7ecf\u627e\u5230\uff0c\u73b0\u5728\u53ea\u9700\u6bd4\u8f83\u66ff\u6362\n         if(max_num > A[i] && A[i] != max_num ) {\n             value = A[i];\n             A[i] = max_num;\n             A[index] = value;\n             break;\n         }\n         max_num ='0';\n    }\n\n    return Integer.valueOf(new String(A)); \n}",
            "title": "Maximum Swap"
        },
        {
            "location": "/\u5176\u4ed6/Merge Sorted Array/",
            "text": "/*\n88. Merge Sorted Array\n\n\nGiven two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.\n\n\nNote:\nYou may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.\n*/\n\n\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\n    int j=0;\n    if(n != 0) \n        for (int i = m; i < m+n; i++) \n            nums1[i] = nums2[j++];\n    Arrays.sort(nums1);\n}",
            "title": "Merge Sorted Array"
        },
        {
            "location": "/\u5176\u4ed6/Missing Number(\u5f02\u6216)/",
            "text": "/*\n268. Missing Number\n\n\nGiven an array containing n distinct numbers taken from 0, 1, 2, ..., n, \nfind the one that is missing from the array.\n\n\nFor example,\nGiven nums = [0, 1, 3] return 2.\n\n\nNote:\nYour algorithm should run in linear runtime complexity. \nCould you implement it using only constant extra space complexity?\n\n\n\u5927\u610f\u5c31\u662f\u5728{0, 1, 2, ..., n}\u627e\u51fa\u9057\u5931\u7684\u6570\u5b57\uff0c\u5982\u679c\u6ca1\u6709\u9057\u5931return n+1\uff1b\n*/\n\n\n//\u4e8c\u5206\u641c\u7d22\npublic int missingNumber(int[] nums) {\n    Arrays.sort(nums);\n    int min = 0, max = nums.length - 1;\n    while(min < max){\n        int mid = (min + max) / 2;\n        // \u6ca1\u9519\u4f4d\uff0c\u5728\u53f3\u8fb9\uff1b\u6709\u9519\u4f4d\uff0c\u5219\u5728\u5de6\u8fb9\n        if(mid == nums[mid]){\n            min = mid + 1;\n        } else {\n            max = mid - 1;\n        }\n    }\n    // \u5982\u679c\u6ca1\u6709\u9519\u4f4d\uff0c\u5219\u8fd4\u56de\u6700\u540e\u4e00\u4e2a\u6570\u52a01\n    return nums[min] == min ? min + 1 : min;\n}\n\n/*\n\u5f02\u6216\u8fd0\u7b97:a^b^b=a;\u5f02\u6216\u4e24\u6b21\u76f8\u540c\u6570\u5b57b\uff0c\u5c06\u5f97\u5230\u539f\u6765\u6570\u5b57a\n\u8fd0\u7b97\u6cd5\u5219\uff1a1^1=0; 1^0=1; 0^0=0;(\u5f02\u6216\u662f\u4e8c\u8fdb\u5236\u8fd0\u7b97\u7b26)\neg\uff1a2^3 =2(\u5341\u8fdb\u5236) -> 10^11 = 1 (\u4e8c\u8fdb\u5236)\n*/\npublic int missingNumber(int[] nums) {\n\n    int xor = 0, i = 0;\n    for (i = 0; i < nums.length; i++) {\n        xor ^= i ^ nums[i];\n    }\n\n    return xor ^ i;\n}\n\n\n//other\npublic static int missingNumber(int[] nums) {\n    int sum = nums.length;\n    for (int i = 0; i < nums.length; i++)\n        sum += i - nums[i];\n    return sum;\n}",
            "title": "Missing Number(\u5f02\u6216)"
        },
        {
            "location": "/\u5176\u4ed6/Move Zeroes/",
            "text": "\ufeff/*\n283. Move Zeroes\n\n\nGiven an array nums, write a function to move all 0's to the end of it \nwhile maintaining the relative order of the non-zero elements.\nFor example, given nums = [0, 1, 0, 3, 12], after calling your function,\nnums should be [1, 3, 12, 0, 0].\n\n\nNote:\nYou must do this in-place without making a copy of the array.\nMinimize the total number of operations.\nCredits:\nSpecial thanks to @jianchao.li.fighter for adding this problem and creating all test cases.\n*/\n\n\npublic static void moveZeroes(int[] nums) {\n    int count=0,j=0;\n    for (int i = 0; i < nums.length; i++)\n        if (nums[i]==0) count++;\n    if(count>0) {\n        for (int i = 0; i < nums.length; i++)\n            if (nums[i]!=0) \n                nums[j++] = nums[i];\n        for (int i = nums.length-count; i < nums.length; i++) \n            nums[i]=0;      \n    }        \n}",
            "title": "Move Zeroes"
        },
        {
            "location": "/\u5176\u4ed6/My Calendar I/",
            "text": "/*\n729. My Calendar I\n\n\nImplement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking.\n\n\nYour class will have the method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start <= x < end.\n\n\nA double booking happens when two events have some non-empty intersection (ie., there is some time that is common to both events.)\n\n\nFor each call to the method MyCalendar.book, return true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar.\n\n\nYour class will be called like this: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)\nExample 1:\nMyCalendar();\nMyCalendar.book(10, 20); // returns true\nMyCalendar.book(15, 25); // returns false\nMyCalendar.book(20, 30); // returns true\nExplanation: \nThe first event can be booked.  The second can't because time 15 is already booked by another event.\nThe third event can be booked, as the first event takes every time less than 20, but not including 20.\n*/\n\n\n// Time Limit Exceeded\nclass MyCalendar {\n    ArrayList<Integer> list;\n    public MyCalendar() {\n       list = new ArrayList<>(); \n    }\n\n    public boolean book(int start, int end) {\n        boolean status =false;\n        for (int i = start; i < end; i++) \n            if(list.contains(i))\n                status = true;\n        for (int i = start; i < end && !status; i++) {\n            list.add(i);\n        }\n        if(status)\n            return false;\n        return true;\n    }\n}\n\n//\u7b2c\u4e8c\u79cd\u601d\u8def\u662f\u6253\u7b97\u7528\u957f\u5ea6\u4e3a2\u7684\u6570\u7ec4\u6765\u9650\u5b9a\u8303\u56f4\uff0c\u7136\u540e\u4e0d\u65ad\u66f4\u65b0\uff0c\u4f46\u6ca1\u6709\u8003\u8651\u5230\u4e0d\u53ea\u53ea\u6709\u4e00\u6bb5\uff0cfail\nclass MyCalendar {\n    int []a;\n    public MyCalendar() {\n       a = new int[2]; \n    }\n\n    public boolean book(int start, int end) {\n        if (a[0]==0 && a[1]==0) {\n            a[0]=start;\n            a[1]=end;\n            return true;\n        }\n        if (start>=a[1]) {\n            a[1]=end;\n            return true;\n        }\n        if (end<=a[0]) {\n            a[0]=start;\n            return true;\n        }\n            return false;\n    }\n}\n\n/*\n\u8fd8\u662f\u56de\u5f52\u5230\u539f\u5148\u7684\u601d\u8def\uff0c\u53ea\u9700\u6539\u53d8list\u7c7b\u578b\u4e3a\u6570\u7ec4\u7c7b\u578b\n\u904d\u5386list\uff0c\u5224\u65ad\uff08start\uff0cend\uff09\u662f\u5426\u5728\u5df2\u6709\u7684\u5c0f\u6570\u7ec4\u91cc\n*/\nclass MyCalendar {\n    ArrayList<Integer[]> list;\n    public MyCalendar() {\n       list = new ArrayList<>(); \n    }\n\n    public boolean book(int start, int end) {\n        for(Integer[] x:list) {\n            if(x[0]<end && start<x[1])\n                return false;\n        }\n        list.add(new Integer[] {start,end});\n        return true;\n    }\n}\n\n\n\n\n/*\n\n * Your MyCalendar object will be instantiated and called as such:\n * MyCalendar obj = new MyCalendar();\n * boolean param_1 = obj.book(start,end);\n \n/",
            "title": "My Calendar I"
        },
        {
            "location": "/\u5176\u4ed6/Non-decreasing Array/",
            "text": "/*\n665. Non-decreasing Array\n\n\nGiven an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.\n\n\nWe define an array is non-decreasing if array[i] <= array[i + 1] holds for every i (1 <= i < n).\n\n\nExample 1:\nInput: [4,2,3]\nOutput: True\nExplanation: You could modify the first \n4\n to \n1\n to get a non-decreasing array.\n\n\nExample 2:\nInput: [4,2,1]\nOutput: False\nExplanation: You can't get a non-decreasing array by modify at most one element.\n\n\nNote: The n belongs to [1, 10,000].\n*/\n\n\n/*\n    \u6211\u539f\u5148\u7684\u60f3\u6cd5\u5c31\u662f\u5185\u5916\u4e24\u5c42\u5faa\u73af\u904d\u5386\u8bbf\u95ee\u6570\u7ec4\uff0c\u627e\u51fa\u4e0d\u7b26\u5408\u8fd9\u4e00\u6761\u4ef6\uff08array[i] <= array[i + 1]\uff09\u7684\u503c\uff0c\u5e76count++\uff1b\u5f53count>1\u65f6\uff0c\u90a3\u4e48\u5c31\u8fd4\u56defalse\uff0c\n\u4f46\u4ee3\u7801\u5b9e\u73b0\u8fc7\u7a0b\u4e2d\u5e76\u4e0d\u80fd\u987e\u5168\u6240\u6709\u7684\u60c5\u51b5\uff0c\u6ca1\u80fdAC\uff1b\n    \u540e\u6765\u53c2\u8003\u4e86\u4e0b\u522b\u4eba\u7684code \uff0c\u53d1\u73b0\u4e8b\u60c5\u6ca1\u90a3\u4e48\u7b80\u5355\uff0c\u5f53array[i-1] > array[i]\u65f6\uff0c\u6211\u4eec\u4f7farray[i-1] = array[i]\uff0c\n\u4f46\u8fd9\u6837\u5982\u679carray[i-2]\u4e0d\u6ee1\u8db3\u5c0f\u4e8earray[i]\uff0c\u5c31\u884c\u4e0d\u901a\u4e86\uff0c\u6240\u4ee5\u5c31\u8981\u5206\u6210\u4e24\u79cd\u60c5\u51b5\u4e86\uff0cif(nums[i-2] <= nums[i]) \u6211\u4eec\u5c31\u53ef\u4ee5\u4f7farray[i-1] = array[i]\uff0c\nelse\uff0c\u6211\u4eec\u6267\u884carray[i] = array[i-1]\uff0c\u8fd9\u6837\u505a\u7684\u76ee\u7684\u5c31\u662f\u4f7f\u7ed3\u679c\u8fd4\u56defalse\uff1b\n*/\n\npublic boolean checkPossibility(int[] nums) {\n    int count=0;        //\u8bb0\u5f55\u662f\u5426\u53ea\u9700\u6700\u591a\u4e00\u4e2a\u4fee\u6539\u5c31\u4f7f\u6570\u7ec4\u7b26\u5408Non-decreasing Array\n    for (int i = 1;i <nums.length && count <=1 ;++i ) {\n            if (nums[i-1] > nums[i]) {\n                count++;\n    //i-2\u8868\u793a\u6570\u7ec4\u524d\u4e24\u4e2a\u53ea\u9700\u8fdb\u884cnums[i-1] = nums[i]\u64cd\u4f5c\uff1b\u5982\u679c\u6ca1\u6709\u8be5\u6761\u4ef6\uff0c\u540e\u7eed\u4e0d\u7ba1\u6570\u7ec4\u5143\u7d20\u5927\u5c0f\u5982\u4f55\uff0cnums[i] > nums[i-1]\u4f1a\u4e00\u76f4\u5b58\u5728\n                if(i-2< 0 || nums[i-2] <= nums[i])  \n                    nums[i-1] = nums[i];\n                else\n                    nums[i] = nums[i-1];\n            }\n        }\n    return count<=1;\n}",
            "title": "Non decreasing Array"
        },
        {
            "location": "/\u5176\u4ed6/Palindrome Number/",
            "text": "/*\n9. Palindrome Number\n\n\nDetermine whether an integer is a palindrome. Do this without extra space.\n*/\n\n\n//\u5229\u7528\u6808\npublic boolean isPalindrome(int x) {\n    if(x<0)\n        return false;\n    LinkedList<Integer> palindrome = new LinkedList<>();\n    int y = x;\n    while(x != 0){\n        palindrome.push(x%10);\n        x = x/10;\n    }\n\n    while(y != 0 && ! palindrome.isEmpty()){\n        if(y%10 != palindrome.pop())\n            return false;\n        y = y/10;\n    }\n    return true;\n}\n\n\n//\u5c06x\u8f6c\u6362\u4e3achar\u6570\u7ec4\npublic boolean isPalindrome(int x) {\n    if(x<0)\n        return false;\n    char [] sum = Integer.toString(x).toCharArray();\n    int i=0,j=sum.length-1;\n    while(i<j){\n        if(sum[i] != sum[j])\n            return false;\n        i++;\n        j--;\n    }\n    return true;\n}",
            "title": "Palindrome Number"
        },
        {
            "location": "/\u5176\u4ed6/Pascal's Triangle/",
            "text": "/*\n118. Pascal's Triangle\n\nGiven numRows, generate the first numRows of Pascal's triangle.\n\nFor example, given numRows = 5,\nReturn\n\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]\n\n*/\n\n//\u8be5\u9898\u7b97\u662f\u4e2d\u7b49\u96be\u5ea6\uff0c\u4e3b\u8981\u8003\u5bdf\u5bf9List\u7684\u4f7f\u7528\uff0c\u6700\u53eb\u4eba\u62cd\u624b\u53eb\u7edd\u5728\uff1aj<row.size()-1\npublic List<List<Integer>> generate(int numRows) {\n    List<List<Integer>> allrows = new ArrayList<List<Integer>>();\n    ArrayList<Integer> row = new ArrayList<Integer>();\n    for(int i=0;i<numRows;i++)\n    {\n        row.add(0, 1);\n        for(int j=1;j<row.size()-1;j++)\n            row.set(j, row.get(j)+row.get(j+1));\n        allrows.add(new ArrayList<Integer>(row));\n    }\n    return allrows;\n}\n\n\n/*\n119. Pascal's Triangle II\n\nGiven an index k, return the kth row of the Pascal's triangle.\n\nFor example, given k = 3,\nReturn [1,3,3,1].\n\nNote:\nCould you optimize your algorithm to use only O(k) extra space?\n*/\n\npublic List<Integer> getRow(int rowIndex) {\n    List<Integer> row = new ArrayList<Integer>();\n    for (int i = 0; i <= rowIndex; i++) {\n        row.add(0,1);\n        for (int j = 1; j < row.size()-1; j++) \n            row.set(j,row.get(j) + row.get(j+1));\n    }\n    return row;\n}",
            "title": "Pascal's Triangle"
        },
        {
            "location": "/\u5176\u4ed6/Reshape the Matrix/",
            "text": "\ufeff/*\n566. Reshape the Matrix\n\n\nIn MATLAB, there is a very useful function called 'reshape', which can reshape a matrix into a new one with different \nsize but keep its original data.You're given a matrix represented by a two-dimensional array, and two positive integers r and c \nrepresenting the row number and column number of the wanted reshaped matrix, respectively.\nThe reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.\nIf the 'reshape' operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, \noutput the original matrix.\n\n\nExample 1:\nInput: \nnums = \n[[1,2],\n [3,4]]\nr = 1, c = 4\nOutput: \n[[1,2,3,4]]\nExplanation:\nThe row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.\nExample 2:\nInput: \nnums = \n[[1,2],\n [3,4]]\nr = 2, c = 4\nOutput: \n[[1,2],\n [3,4]]\nExplanation:\nThere is no way to reshape a 2 * 2 matrix to a 2 * 4 matrix. So output the original matrix.\nNote:\nThe height and width of the given matrix is in range [1, 100].\nThe given r and c are all positive.\n\n\n*/\n\n\nclass Solution {\n    public int[][] matrixReshape(int[][] nums, int r, int c) {\n        int [][] snums = new int [r][c];\n        int [] a = new int [nums.length*nums[0].length];//\u4ee3\u8868\u884c\u548c\u5217\n         //\u5c06\u4e8c\u7ef4\u6570\u7ec4nums[][]\u6309\u884c\u6570\u8f6c\u6362\u4e3a\u4e00\u7ef4\u6570\u7ec4a[]\n         for (int i = 0; i < nums.length; i++) {\n            for (int j = 0; j < nums[0].length; j++) {\n                a[i*nums[0].length + j] = nums[i][j];\n            }\n        }\n\n         //\u4e0d\u7b26\u5408\u89c4\u8303\u7684\u60c5\u51b5\n         if (r*c > nums.length * nums[0].length) {\n            return nums;\n        }else {\n            for (int i = 0; i < r; i++) {\n                for (int j = 0; j < c; j++) {\n                    snums[i][j] = a[i*c + j];\n                }\n            }\n        }\n         return snums;\n    }\n}",
            "title": "Reshape the Matrix"
        },
        {
            "location": "/\u5176\u4ed6/Reverse Integer/",
            "text": "/*\n7. Reverse Integer\n\n\nReverse digits of an integer.\n\n\nExample1: x = 123, return 321\nExample2: x = -123, return -321\n\n\nIf the integer's last digit is 0, what should the output be? ie, cases such as 10, 100.\nDid you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, \nthen the reverse of 1000000003 overflows. How should you handle such cases?\nFor the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.\n\n\nNote:\nThe input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows.\n*/\n\n\n//\u601d\u8def\u5176\u5b9e\u5f88\u7b80\u5355\uff0c\u6ce8\u610f\u4e0a\u9762\u7684\u4e00\u4e9b\u8d1f\u6570\u548c\u8d85\u8303\u56f4\u6570\u7684\u5904\u7406\uff0c\u7136\u540e\u95ee\u9898\u5c31\u53ea\u662f\u6570\u5b57\u4e0e\u5b57\u7b26\u7684\u8f6c\u6362\npublic int reverse(int x) {\n    int value=0,j=0;\n    char [] sum = Integer.toString(x).toCharArray();\n\n    for (int i = 0; i < sum.length; i++) {\n        if(sum[i] == '-') \n            continue;       \n\n        value += (sum[i] - '0') * Math.pow(10, j++);\n    } \n    if(value == 2147483647)\n        return 0;\n\n    if (x < 0) \n        value = - value;\n\n    return value;\n}\n\n//\u5f53\u7136\u6211\u4eec\u8fd8\u53ef\u4ee5\u8fd0\u7528\u6570\u5b66\u8fd0\u7b97\u7b26 ' % \u548c / ' \u7684\u7279\u70b9\uff0c\u8fd9\u6837\u5c31\u663e\u5f97\u66f4\u7b80\u5355\u66f4\u6709\u6548\u7387\u3002\npublic int reverse(int x) {\n    long value = 0;\n    while(x != 0){\n        value = value*10 + x%10;\n        x = x/10;\n        if(value> Integer.MAX_VALUE || value < Integer.MIN_VALUE)\n            return 0;                \n    }\n    return (int)value;    \n}",
            "title": "Reverse Integer"
        },
        {
            "location": "/\u5176\u4ed6/Rotate Array/",
            "text": "/*\n189. Rotate Array\n\n\nRotate an array of n elements to the right by k steps.\nFor example, with n = 7 and k = 3, the array [1,2,3,4,5,6,7] is rotated to [5,6,7,1,2,3,4].\n\n\nNote:\nTry to come up as many solutions as you can, there are at least 3 different ways to solve this problem.\n\n\n*/\n\n\n/*\nIntuition:\n   \u9898\u76ee\u7684\u610f\u601d\u5c31\u662f\u5c06\u6700\u540e\u4e00\u4f4d\u79fb\u52a8\u5230\u7b2c\u4e00\u4f4d\uff0c\u79fb\u52a8\u7684\u6b21\u6570\u4e3ak\uff0c\u76f4\u63a5\u5237\n*/\n//Time complexity : O(n*k); Space complexity : O(1); \u663e\u7136\u6548\u7387\u4e0d\u9ad8\n public void rotate(int[] nums, int k) {\n    int len = nums.length; \n    int value, j =0 ; \n    k %= len;\n    while(j != k) {\n        value = nums[len-1];\n        //\u6240\u4ee5\u6570\u503c\u5411\u540e\u79fb\u52a8\u4e00\u4f4d\n        for (int j2 = len-1; j2 > 0; j2--) \n            nums[j2]=nums[j2-1];\n\n        nums[0] = value;\n        ++j;\n    }\n\n}\n\n\n\n/*\n\u9996\u5148\u53cd\u8f6c\u6574\u4e2a\u6570\u7ec4nums\uff0c\u7136\u540e\u53cd\u8f6cnums(0,k-1)\uff0c\u6700\u540e\u53cd\u8f6cnums(k, len-1)\nTime complexity : O(n); Space complexity : O(1);\n*/\n\npublic class Solution {\n    public void rotate(int[] nums, int k) {\n        k %= nums.length;\n        reverse(nums, 0, nums.length - 1);\n        reverse(nums, 0, k - 1);\n        reverse(nums, k, nums.length - 1);\n    }\n    public void reverse(int[] nums, int start, int end) {\n        while (start < end) {\n            int temp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}",
            "title": "Rotate Array"
        },
        {
            "location": "/\u5176\u4ed6/Search Insert Position/",
            "text": "\ufeff/*\n35. Search Insert Position\n\n\nGiven a sorted array and a target value, return the index if the target is found. If not, return the index where \nit would be if it were inserted in order.\nYou may assume no duplicates in the array.\n\n\nHere are few examples.\n[1,3,5,6], 5 \u2192 2\n[1,3,5,6], 2 \u2192 1\n[1,3,5,6], 7 \u2192 4\n[1,3,5,6], 0 \u2192 0\n\n\n*/\n\n\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        //\u67e5\u627etarget\u8bb0\u5f55\u4f4d\u7f6e\n        int status=Arrays.binarySearch(nums, target);\n\n        //\u5982\u679ctarget\u4e0d\u5728\u6570\u7ec4\u5185\uff0c\u5219\u63d2\u5165\u5230\n        if(status<0) {\n            for (int i = 0; i < nums.length; i++){\n                if (target<nums[i]) {\n                    status=i;\n                    break;\n                }\n            }\n\n            if(target > nums[nums.length-1])status=nums.length;\n        }\n\n        return status;\n    }\n}",
            "title": "Search Insert Position"
        },
        {
            "location": "/\u5176\u4ed6/Search for a Range\uff08List\u8f6c\u4e3aint\uff09/",
            "text": "/*\n34. Search for a Range\n\n\nGiven an array of integers sorted in ascending order, find the starting and ending position of a given target value.\n\n\nYour algorithm's runtime complexity must be in the order of O(log n).\n\n\nIf the target is not found in the array, return [-1, -1].\n\n\nFor example,\nGiven [5, 7, 7, 8, 8, 10] and target value 8,\nreturn [3, 4].\n\n\n\u9898\u610f\uff1a\n\n\n    \u627e\u5230\u6570\u7ec4nums\u4e2d\u503c\u7b49\u4e8etarget\u7684\u7b2c\u4e00\u4e2a\u548c\u6700\u540e\u4e00\u4e2a\n\n\n\n*/\n\n\npublic int[] searchRange(int[] nums, int target) {\n        int a[]={-1,-1};\n        int i = 0, j = nums.length-1;\n        boolean status1 = false,status2 = false;\n        while((!status1 || !status2) && i<=j){\n            if(nums[i] != target)\n                ++i;\n            else\n                status1 =true;\n\n            if(nums[j] != target)\n                --j;\n            else \n                status2 =true;\n        }\n        if(i<=j && status1){\n            a[0] = i;\n            a[1] = j;\n        }\n        return a;   \n    }\n/*\nList\u8f6c\u4e3aint(\u62d3\u5c55)\nLinkedList<Integer> linkedList = new LinkedList<>();    \n        int []a = new int[linkedList.size()];\n        for (int i = 0; i < linkedList.size(); i++) \n            a[i] = linkedList.get(i);\n\n\nInteger []a = new Integer[set.size()];\n        set.toArray(a);\n*/",
            "title": "Search for a Range\uff08List\u8f6c\u4e3aint\uff09"
        },
        {
            "location": "/\u5176\u4ed6/Search for a Range\uff08List\u8f6c\u4e3aint\uff09/#_1",
            "text": "\u627e\u5230\u6570\u7ec4nums\u4e2d\u503c\u7b49\u4e8etarget\u7684\u7b2c\u4e00\u4e2a\u548c\u6700\u540e\u4e00\u4e2a  */  public int[] searchRange(int[] nums, int target) {\n        int a[]={-1,-1};\n        int i = 0, j = nums.length-1;\n        boolean status1 = false,status2 = false;\n        while((!status1 || !status2) && i<=j){\n            if(nums[i] != target)\n                ++i;\n            else\n                status1 =true;\n\n            if(nums[j] != target)\n                --j;\n            else \n                status2 =true;\n        }\n        if(i<=j && status1){\n            a[0] = i;\n            a[1] = j;\n        }\n        return a;   \n    }\n/*\nList\u8f6c\u4e3aint(\u62d3\u5c55)\nLinkedList<Integer> linkedList = new LinkedList<>();    \n        int []a = new int[linkedList.size()];\n        for (int i = 0; i < linkedList.size(); i++) \n            a[i] = linkedList.get(i);\n\n\nInteger []a = new Integer[set.size()];\n        set.toArray(a);\n*/",
            "title": "\u9898\u610f\uff1a"
        },
        {
            "location": "/\u5176\u4ed6/Shortest Unsorted Continuous Subarray/",
            "text": "\ufeff/*\n581. Shortest Unsorted Continuous Subarray\n\n\nGiven an integer array, you need to find one continuous subarray that if you only sort \nthis subarray in ascending order, then the whole array will be sorted in ascending order, too.\nYou need to find the shortest such subarray and output its length.\n\n\nExample 1:\nInput: [2, 6, 4, 8, 10, 9, 15]\nOutput: 5\nExplanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array \nsorted in ascending order.\nNote:\nThen length of the input array is in range [1, 10,000].\nThe input array may contain duplicates, so ascending order here means <=.\n*/\n\n\n/*\n(1)\u60f3\u8fd9\u9053\u9898\u7684\u65f6\u5019\uff0c\u521a\u5f00\u59cb\u5c31\u60f3\u592a\u590d\u6742\u4e86\uff0c\u539f\u5148\u7684\u601d\u8def\u662f\u590d\u5236\u6570\u7ec4nums[]\u5e76sort()\u6210snums[]\uff0c\n\u7136\u540e\u904d\u5386\u6570\u7ec4nums[],\u6bd4\u8f83nums[i]\u548csnums[i]\u7684\u503c\uff0c\u5982\u679c\u4e0d\u540c\u5219\u8df3\u8f6c\u5230nums[i]\u5728snums[i]\u6240\u5728\u4f4d\u7f6e,\u4f9d\u6b21\u7c7b\u63a8\u3002\n*/\nclass Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        int b[] =new int[nums.length];\n         int variable=0,len=0;\n         for (int i = 0; i < nums.length; i++) {\n            b[i]=nums[i];\n        }\n\n         Arrays.sort(b);\n\n         for (int i = 0; i < nums.length; i++) {\n                if(b[i]==nums[i]) ++variable;\n                else break;\n            }\n         if (variable==nums.length) variable=1; \n        int j=0,count;//j\uff1a\u7d22\u5f15\u53f7\n         //\u904d\u5386\u6570\u7ec4a[],\u6bd4\u8f83\u4e24\u503c\n         for (int i = 0; i < nums.length; ++i) {\n             //\u4e3a\u4ec0\u4e48int i=j\uff0cj\u7684\u503c\u4e0d\u80fd\u4f20\u9012\u7ed9i\uff1f\n                if (nums[i] >=b[i]) { \n                    count=0;\n                    for (int k = 0; k < b.length; k++) {\n                        if(nums[i]==b[k])count++;\n                    }\n                    count=count-1;\n                    if(nums[nums.length-1]==nums[nums.length-2])count=count-1;\n                    i=Arrays.binarySearch(b, nums[i])+count;\n                    j=i;\n                }\n            }\n         len=j+1-variable;\n         return len;\n    }\n}\n\n\n\n\n/\n\n(2)\u4f46\u5b9e\u8df5\u540e\uff0c\u5f88\u663e\u7136\u8fd9\u6837\u7684\u601d\u8def\u5e76\u4e0d\u62bd\u8c61\uff0c\u5b9e\u73b0\u8fc7\u7a0b\u5f88\u9ebb\u70e6\uff0c\u4e0d\u80fd\u987e\u5168\u6240\u6709\u6570\u636e\uff0c\u800c\u4e14\u5f88\u8017\u65f6\u95f4\uff0c\u7ed3\u679c\u4e5f\u662f\u9519\u8bef\u7684\uff0c\n\u53ea\u80fd\u88ab\u8feb\u653e\u5f03\uff0c\u540e\u6765\u53c2\u8003\u4e0b\u4e86\u522b\u4eba\u7684\u601d\u8def\uff0c\u8fd8\u662f\u592anaive\u4e86\u3002\n\u601d\u8def\uff1a\u590d\u5236\u6570\u7ec4nums[]\u5e76sort()\u6210snums[]\uff0c\u6bd4\u8f83\u4e24\u4e2a\u6570\u7ec4\u4e0d\u540c\u7684\u503c\uff0c\u5e76\u8bb0\u4e0b\u6700\u5148\u7684\u4e0d\u540c\u503c\u7684\u7d22\u5f15\u53f7\uff1astart\uff1b\n\u548c\u6700\u540e\u7684\u4e0d\u540c\u503c\u7684\u7d22\u5f15\u53f7\uff1aend\uff1b\u6700\u540ereturn (end - start >= 0 ? end - start + 1 : 0);\n\n/\n\n\nclass Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        int[] snums = nums.clone();\n        Arrays.sort(snums);\n        int start = snums.length, end = 0;\n        for (int i = 0; i < snums.length; i++) {\n            if (snums[i] != nums[i]) {\n                start = Math.min(start, i);\n                end = Math.max(end, i);\n            }\n        }\n        return (end - start >= 0 ? end - start + 1 : 0);\n    }\n}",
            "title": "Shortest Unsorted Continuous Subarray"
        },
        {
            "location": "/\u5176\u4ed6/Subarray Sum Equals K/",
            "text": "/*\n560. Subarray Sum Equals K\n\n\nGiven an array of integers and an integer k, you need to find \nthe total number of continuous subarrays whose sum equals to k.\n\n\nExample 1:\nInput:nums = [1,1,1], k = 2\nOutput: 2\n*/\n\n\npublic int subarraySum(int[] nums, int k) {\n    int count=0,sum=0;\n    for (int i = 0; i < nums.length; i++) {\n        sum=nums[i];\n        if(sum==k)\n            count++;\n        for (int j = i+1; j < nums.length; j++) {\n            sum+=nums[j];\n            if (sum==k) {\n                count++;\n                continue;\n            }\n        }\n    }\n    return count;\n}",
            "title": "Subarray Sum Equals K"
        },
        {
            "location": "/\u5176\u4ed6/Third Maximum Number/",
            "text": "\ufeff/*\n414. Third Maximum Number\n\n\nGiven a non-empty array of integers, return the third maximum number in this array. \nIf it does not exist, return the maximum number. The time complexity must be in O(n).\n\n\nExample 1:\nInput: [3, 2, 1]\nOutput: 1\nExplanation: The third maximum is 1.\n\n\nExample 2:\nInput: [1, 2]\nOutput: 2\nExplanation: The third maximum does not exist, so the maximum (2) is returned instead.\n\n\nExample 3:\nInput: [2, 2, 3, 1]\nOutput: 1\nExplanation: Note that the third maximum here means the third maximum distinct number.\nBoth numbers with value 2 are both considered as second maximum.\n*/\n\n\npublic int thirdMax(int[] nums) {\n        Arrays.sort(nums);\n        int count=0,value=nums[0];\n\n        if (nums.length<3) {\n\n            for (int i = 0; i < nums.length; i++) \n                value=Math.max(value, nums[i]);\n\n        }else {\n\n            for (int i = nums.length-1; i > 0; i--) {\n                if (nums[i]>nums[i-1]) {\n                    count++;\n                    if (count==2) {\n                        value=nums[i-1];\n                        break;\n                    } \n                }\n            }\n            if(count<2)\n                value=nums[nums.length-1];\n        }\n\n        return value;\n    }",
            "title": "Third Maximum Number"
        },
        {
            "location": "/\u5176\u4ed6/Two Sum II/",
            "text": "/*\n167. Two Sum II - Input array is sorted\n\n\nGiven an array of integers that is already sorted in ascending order, find two numbers such that \nthey add up to a specific target number.The function twoSum should return indices of the two numbers \nsuch that they add up to the target, where index1 must be less than index2. \nPlease note that your returned answers (both index1 and index2) are not zero-based.\n\n\nYou may assume that each input would have exactly one solution and you may not use the same element twice.\n\n\nInput: numbers={2, 7, 11, 15}, target=9\nOutput: index1=1, index2=2\n\n\n\u601d\u8def\u5f88\u7b80\u5355\uff0c\u4e5f\u4e0d\u77e5\u9053\u600e\u4e48\u5566\uff0c\u6211TM\u521a\u5f00\u59cb\u5728for\u5faa\u73af\u91cc\u628a numbers.length-1 \u5199\u6210 num.length-1;\n\u6d6a\u8d39\u4e86\u597d\u591a\u65f6\u95f4\uff0c\u6572\u4ee3\u7801\u8fd8\u662f\u8981\u7ec6\u5fc3\n*/\n\n\npublic int[] twoSum(int[] numbers, int target) {\n    int []num = new int[2];\n    int value;\n    for (int i = 0; i < numbers.length-1; i++) {\n        value = target - numbers[i];\n        if (Arrays.binarySearch(numbers,i+1,numbers.length,value) >i) {\n            num[0] = i+1;\n            num[1] = Arrays.binarySearch(numbers,i+1,numbers.length, value)+1;\n            break;\n        } \n    }\n    return num;\n}",
            "title": "Two Sum II"
        },
        {
            "location": "/\u6811/Merge Two Binary Trees/",
            "text": "/*\n617. Merge Two Binary Trees\n\nGiven two binary trees and imagine that when you put one of them to cover the other, \nsome nodes of the two trees are overlapped while the others are not.\nYou need to merge them into a new binary tree. The merge rule is that if two nodes overlap, \nthen sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.\n\nExample 1:\nInput: \n\n    Tree 1                     Tree 2                  \n          1                         2                             \n         / \\                       / \\                            \n        3   2                     1   3                        \n       /                           \\   \\                      \n      5                             4   7                  \nOutput: \nMerged tree:\n         3\n        / \\\n       4   5\n      / \\   \\ \n     5   4   7\n\n*/\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n    if (t1 == NULL)\n        return t2;\n    if(t2 == NULL)\n        return t1;\n    t1->val += t2->val;\n    t1->left = mergeTrees(t1->left , t2->left);\n    t1->right = mergeTrees(t1->right , t2->right);\n    return t1;\n    }\n};",
            "title": "Merge Two Binary Trees"
        }
    ]
}